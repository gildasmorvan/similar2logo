<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>README</title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="template.css" />
</head>
<body>
    <div class="container">
    <div class="row">
            <div class="span12">
            <p><img src="src/main/doc/img/similar2logo-logo-small.png" /></p>
<p>Similar2Logo is a Logo-like <strong>multiagent-based simulation environment</strong> based on the <a href="http://www.lgi2a.univ-artois.fr/~morvan/similar.html">SIMILAR</a> API and released under the <a href="http://cecill.info">CeCILL-B license</a>.</p>
<p>Similar2Logo is written in <a href="https://en.wikipedia.org/wiki/Java_(software_platform)">Java</a>. The GUI is based on web technologies (<a href="https://en.wikipedia.org/wiki/HTML5">HTML5</a>/<a href="https://en.wikipedia.org/wiki/Cascading_Style_Sheets">CSS</a>/<a href="https://en.wikipedia.org/wiki/JavaScript">js</a>). Simulations can be developed in Java, <a href="https://en.wikipedia.org/wiki/Groovy_(programming_language)">Groovy</a>, <a href="https://en.wikipedia.org/wiki/Ruby_(programming_language)">Ruby</a>, <a href="https://kotlinlang.org">Kotlin</a>, <a href="https://www.python.org">Python</a> or any <a href="https://en.wikipedia.org/wiki/List_of_JVM_languages">JVM language</a>.</p>
<p>The purpose of Similar2Logo is not to offer a fully integrated agent-based modeling environment such as <a href="http://ccl.northwestern.edu/netlogo/">NetLogo</a>, <a href="http://gama-platform.org">Gama</a>, <a href="http://www.madkit.net/turtlekit/">TurtleKit</a> or <a href="https://repast.github.io">Repast</a> but to explore the potential of</p>
<ul>
<li><p>the <strong>influences/reaction model</strong>, developed by the <a href="http://www.lirmm.fr/recherche/equipes/smile">SMILE</a> team of <a href="http://www.lirmm.fr">LIRMM</a> lab at <a href="http://www.umontpellier.fr">Université de Montpellier</a>,</p></li>
<li><p>the <a href="http://www.cristal.univ-lille.fr/SMAC/projects/ioda/"><strong>interaction-oriented modeling</strong></a> approach developed by the <a href="http://www.cristal.univ-lille.fr/SMAC/">SMAC</a> team of <a href="http://cristal.univ-lille.fr">CRISTAL</a> lab at <a href="https://www.univ-lille.fr">Université de Lille</a>,</p></li>
<li><p><a href="https://www.lgi2a.univ-artois.fr/~morvan/mlabm.html">multi-level agent-based modeling</a></p></li>
<li><p><strong>web technologies</strong> to produce portable simulations.</p></li>
</ul>
<p>To understand the philosophy of Similar2Logo, it might be interesting to first look at the <a href="http://www.lgi2a.univ-artois.fr/~morvan/similar/docs/README.html">SIMILAR documentation</a> and read the papers about the <a href="http://www.aaai.org/Papers/ICMAS/1996/ICMAS96-009.pdf">influences/reaction model</a>, the <a href="http://www.aamas-conference.org/Proceedings/aamas07/html/pdf/AAMAS07_0179_07a7765250ef7c3551a9eb0f13b75a58.pdf">IRM4S (Influence/Reaction Principle for Multi-Agent Based Simulation) model</a> and the <a href="https://hal.inria.fr/hal-00825534/document">interaction-oriented modeling</a> approach.</p>
<h1 id="contents-of-the-readme">Contents of the README</h1>
<ul>
<li><p><a href="#license">License</a></p></li>
<li><p><a href="#contributors">Contributors</a></p></li>
<li><p><a href="#run">Compiling and running Similar2Logo</a></p>
<ul>
<li><p><a href="#run-similar2logo">Running Similar2Logo</a></p></li>
<li><p><a href="#run-cloud">Cloud demo</a></p></li>
<li><p><a href="#run-binary">Using the binary distribution</a></p></li>
<li><p><a href="#run-git">Compile Similar2Logo from the git repository</a></p></li>
<li><p><a href="#run-jupyter">Executing examples from jupyter notebooks</a></p></li>
</ul></li>
<li><p><a href="#architecture">Technical architecture of Similar2Logo</a></p></li>
<li><p><a href="#develop">Develop your own agent-based models</a></p>
<ul>
<li><p><a href="#structure">Basic structure of a Similar2Logo simulation</a></p></li>
<li><p><a href="#jexamples">Java examples</a></p>
<ul>
<li><p><a href="#jpassive">A first example with a passive turtle</a></p></li>
<li><p><a href="#jboids">Adding a user-defined decision model to the turtles: The boids model</a></p></li>
<li><p><a href="#jturmite">Dealing with marks: the turmite model</a></p></li>
<li><p><a href="#jmultiturmite">Adding an interaction and a user-defined reaction model: The multiturmite model</a></p></li>
<li><p><a href="#jsegregation">Adding user-defined influence, reaction model and GUI: The segregation model</a></p></li>
<li><p><a href="#jheatbugs">Adding a hidden state to the turtles and a pheromone field: The heatbugs model</a></p></li>
</ul></li>
<li><p><a href="#gexamples">Groovy examples</a></p>
<ul>
<li><p><a href="#gpassive">A first example with a passive turtle</a></p></li>
<li><p><a href="#gboids">Adding a user-defined decision model to the turtles: The boids model</a></p></li>
<li><p><a href="#gturmite">Dealing with marks: the turmite model</a></p></li>
<li><p><a href="#gsegregation">Adding user-defined influence, reaction model and GUI: The segregation model</a></p></li>
</ul></li>
<li><p><a href="#rexamples">Ruby examples</a></p>
<ul>
<li><p><a href="#rpassive">A first example with a passive turtle</a></p></li>
<li><p><a href="#rboids">Adding a user-defined decision model to the turtles: The boids model</a></p></li>
<li><p><a href="#rturmite">Dealing with marks: the turmite model</a></p></li>
<li><p><a href="#rsegregation">Adding user-defined influence, reaction model and GUI: The segregation model</a></p></li>
</ul></li>
<li><p><a href="#kexamples">Kotlin examples</a></p>
<ul>
<li><p><a href="#kpassive">A first example with a passive turtle</a></p></li>
<li><p><a href="#kboids">Adding a user-defined decision model to the turtles: The boids model</a></p></li>
<li><p><a href="#kturmite">Dealing with marks: the turmite model</a></p></li>
<li><p><a href="#kmultiturmite">Adding an interaction and a user-defined reaction model: The multiturmite model</a></p></li>
<li><p><a href="#ksegregation">Adding user-defined influence, reaction model and GUI: The segregation model</a></p></li>
</ul></li>
<li><p><a href="#pexamples">Python examples</a></p>
<ul>
<li><p><a href="#ppassive">A first example with a passive turtle</a></p></li>
<li><p><a href="#pboids">Adding a user-defined decision model to the turtles: The boids model</a></p></li>
<li><p><a href="#pturmite">Dealing with marks: the turmite model</a></p></li>
<li><p><a href="#pmultiturmite">Adding an interaction and a user-defined reaction model: The multiturmite model</a></p></li>
</ul></li>
</ul></li>
</ul>
<h1 id="license"><a name="license"></a> License</h1>
<p>Similar2Logo is distributed under the <a href="http://cecill.info">CeCILL-B license</a>. In a few words, “if the initial program is under CeCILL-B, you can distribute your program under any license that you want (without the need to distribute the source code) provided you properly mention the use that you did of the initial program” (from the <a href="http://www.cecill.info/faq.en.html#differences">CeCILL FAQ</a> ).</p>
<p>See the file <a href="LICENSE.txt">LICENSE.txt</a> for more information.</p>
<h1 id="contributors"><a name="contributors"></a> Contributors</h1>
<p>Rodrigue FONTAINE - <a href="mailto:rodrigue_fontaine@ens.univ-artois.fr">mail</a> - <a href="https://github.com/rodriguefontaine">homepage</a> - developer.</p>
<p>Jonathan JULIEN - <a href="mailto:julienjnthn@gmail.com">mail</a> - developer.</p>
<p>Yoann KUBERA - <a href="mailto:yoann.kubera@gmail.com">mail</a> - <a href="http://yoannkubera.net/">homepage</a> - designer of the SIMILAR API, developer.</p>
<p>Antoine LECOUTRE - <a href="mailto:Antoine-Lecoutre@outlook.com">mail</a> - developer.</p>
<p>Quentin LEMAIRE - <a href="mailto:quentin.lemaire98@gmail.com">mail</a> - <a href="https://github.com/Hukram">homepage</a> - developer.</p>
<p>Stéphane MEILLIEZ - <a href="mailto:stephane.meilliez@gmail.com">mail</a> - developer.</p>
<p>Gildas MORVAN - <a href="mailto:gildas.morvan@univ-artois.fr">mail</a> - <a href="http://www.lgi2a.univ-artois.fr/~morvan/">homepage</a> - designer, main developer.</p>
<p>Xavier SZKULDAREK - <a href="mailto:developer.xavier.szkudlarek@hotmail.com">mail</a> - <a href="https://github.com/FireFighter18">homepage</a> - developer.</p>
<p>Romain WINDELS - <a href="mailto:romainwindels@yahoo.fr">mail</a> - developer.</p>
<h1 id="compiling-and-running-similar2logo"><a name="run"></a> Compiling and running Similar2Logo</h1>
<h2 id="running-similar2logo"><a name="run-similar2logo"></a> Running Similar2Logo</h2>
<p>When you launch a Similar2Logo simulation, your browser should open a page that looks like this.</p>
<p><img src="src/main/doc/img/boids-example.png" /></p>
<ul>
<li><p>You can change the parameters of the simulation using the panel on the left. When you hover on a parameter, a description of it should appear.</p></li>
<li><p>You can control the simulation execution (start/stop/pause/quit) using the buttons on the upper right.</p></li>
<li><p>The simulation will be displayed in the center of the web page. By default, it will display the turtles, marks and pheromone fields but you can add the visualization you want, for instance, the prey/predator simulation will display the population of preys, predators and grass in a chart.</p></li>
</ul>
<p><img src="src/main/doc/img/predation-example.png" /></p>
<h2 id="cloud-demo"><a name="run-cloud"></a> Cloud demo</h2>
<p>You can try a <a href="https://similar2logo-predationdemo.appspot.com/">demo of the predation example</a> shipped with Similar2Logo from Google cloud. It allows you to run a simulation and change its parameters.</p>
<h2 id="using-the-binary-distribution"><a name="run-binary"></a> Using the binary distribution</h2>
<p>A binary distribution of Similar2Logo can be downloaded at <a href="https://github.com/gildasmorvan/similar2logo/releases/download/v0.9/similar2logo-distribution-0.9-bin.zip">this address</a>. It contains all the needed libraries and some simulation examples. It is probably the easiest way to start using Similar2Logo.</p>
<p>To run a simulation written in Java, use the following command from the root directory of the distribution:</p>
<pre><code>java -cp &quot;lib/*&quot; fr.univ_artois.lgi2a.similar2logo.examples.boids.BoidsSimulationMain</code></pre>
<p>To run a simulation written in Groovy, you must install Groovy on your system and use the following command from the root directory of the distribution:</p>
<pre><code>groovy -cp &quot;lib/*&quot; examples/boids/src/groovy/fr/univ_artois/lgi2a/similar2logo/examples/boids/GroovyBoidsSimulation</code></pre>
<p>To run a simulation written in Python, you must install Jython on your system and use the following command from the root directory of the distribution:</p>
<pre><code>jython  -J-cp &quot;lib/*&quot; examples/boids/src/python/fr/univ_artois/lgi2a/similar2logo/examples/boids/BoidsSimulation.py</code></pre>
<p>To run a simulation written in Ruby, you must install <a href="http://jruby.org">JRuby</a> on your system and use the following command from the root directory of the distribution:</p>
<pre><code>jruby -J-cp &quot;lib/*&quot; examples/boids/src/ruby/fr/univ_artois/lgi2a/similar2logo/examples/boids/RubyBoidsSimulation.rb</code></pre>
<p>Other simulations can be performed using a different main class or script. The main class or script of each simulation example and the corresponding execution command are identified in the README file located in sub-directories of the <code>examples</code> directory of the distribution.</p>
<h2 id="getting-similar2logo-from-the-git-repository"><a name="run-git"></a> Getting Similar2Logo from the git repository</h2>
<p>The Similar2Logo project uses the <a href="https://git-scm.com">git version control system</a> and is hosted on <a href="https://github.com">Github</a>. To compile Similar2Logo from the source you will need a <a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html">Java SE 8 SDK</a> and the software project management tool <a href="https://maven.apache.org">Maven</a>.</p>
<p>To clone the Similar and Similar2Logo repositories, use the following commands:</p>
<pre><code>git clone https://github.com/gildasmorvan/similar.git
git clone https://github.com/gildasmorvan/similar2logo.git</code></pre>
<p>To compile and install Similar and Similar2Logo on your system, use the following commands:</p>
<pre><code>cd similar
mvn install
cd ../similar2logo
mvn install</code></pre>
<p>The Similar2Logo project is divided into several sub-modules</p>
<ul>
<li><p><code>similar2logo-kernel</code> contains the kernel of the platform,</p></li>
<li><p><code>similar2logo-lib</code> contains some useful libraries, such as generic perception and decision models, environment, probes to visualize and interact with the simulations, a web server that controls the execution of simulations, a HTML5/css/js GUI and random number generation tools.</p></li>
<li><p><code>similar2logo-com</code> contains tools based on <a href="http://mecsyco.com">Mecsyco</a> to couple Similar2Logo with other simulators. <strong>Note</strong>: this module is experimental and therefore, not included in the binary distribution of Similar2Logo. To use it, uncomment the line 174 of the <code>pom.xml</code> of the main project.</p></li>
<li><p><code>similar2logo-examples</code> contains simulation model examples written in Java, Groovy, Kotlin, Ruby and Python and, if needed, their associated GUIs. Each example provides a main class that can be used to run the corresponding simulation.</p></li>
<li><p><code>similar2logo-distribution</code> allows to produce the binary distribution of Similar2Logo using the <a href="http://maven.apache.org/plugins/maven-assembly-plugin/">Maven Assembly Plugin</a>.</p></li>
</ul>
<p>When using the git repository version of Similar2Logo, running simulations is easier with a Java IDE supporting maven, such that the <a href="https://eclipse.org/downloads/">eclipse framework</a>. Indeed, such framework automates the identification of the required libraries, and running a simulation simply requires to identify the main class of the simulation and run it through the IDE.</p>
<h2 id="executing-examples-from-jupyter-notebooks"><a name="run-jupyter"></a> Executing examples from jupyter notebooks</h2>
<p>We provide <a href="http://jupyter.org/">jupyer notebooks</a> to try the examples developed in Groovy, Ruby and Python.</p>
<p>The notebooks are located in the <code>similar2logo-examples/src/main/doc</code> directory.</p>
<p>To run the examples you must install the <a href="https://github.com/scijava/scijava-jupyter-kernel">scijava-jupyter-kernel</a> and <a href="https://github.com/gildasmorvan/similar2logo/blob/master/README.md#compiling-similar2logo-with-maven">compile Similar2Logo with maven</a>.</p>
<p>Then run the following commands from the Similar2Logo base directory:</p>
<pre><code>cd similar2logo-examples/src/main/doc/notebooks
jupyter notebook</code></pre>
<h1 id="technical-architecture-of-similar2logo"><a name="architecture"></a> Technical architecture of Similar2Logo</h1>
<p>The following scheme presents the technical architecture of Similar2Logo.</p>
<figure>
<img src="src/main/doc/img/similar2logoArchitecture.png" alt="technical architecture of Similar2Logo" /><figcaption>technical architecture of Similar2Logo</figcaption>
</figure>
<ul>
<li><p>Similar2Logo runs on a web server based on the <a href="http://sparkjava.com">Spark framework</a>. By default it uses the <code>8080</code> port.</p></li>
<li><p>The engine of Similar executes and probes the simulation.</p></li>
<li><p>Users can interact with the simulation using a web GUI based on <a href="http://getbootstrap.com">Bootstrap</a>.</p></li>
<li><p>Similar2Logo uses <a href="http://jquery.com">jQuery</a> to control (start/pause/stop/quit) and change the parameters of the simulations.</p></li>
<li><p>Simulation data are pushed by the web server to the client using the <a href="https://en.m.wikipedia.org/wiki/WebSocket">websocket protocol</a> in <a href="http://www.json.org">JSON</a>.</p></li>
</ul>
<h2 id="the-similar-engine">The Similar engine</h2>
<p>The engine of Similar encapsulates the algorithm that runs a simulation model (see this <a href="https://arxiv.org/pdf/1703.02399.pdf">paper</a> for more information about this algorithm). The default implementation is mono-threaded and executes the simulation as fast as possible. To monitor, interact with or execute the simulation in an other mode (e.g. step by step or in real time), probes can be attached to the engine.</p>
<figure>
<img src="src/main/doc/img/similarEngine.png" alt="the Similar engine" /><figcaption>the Similar engine</figcaption>
</figure>
<h1 id="develop-your-own-multiagent-based-simulations"><a name="develop"></a> Develop your own multiagent-based simulations</h1>
<h2 id="basic-structure-of-a-similar2logo-simulation"><a name="structure"></a> Basic structure of a Similar2Logo simulation</h2>
<p>A typical Similar2Logo simulation will contain the following components:</p>
<ul>
<li><p>If the model is stochastic, a <a href="https://en.wikipedia.org/wiki/Pseudorandom_number_generator"><strong>pseudorandom number generator</strong></a>. The <code>PRNG</code> class is a simple factory relying on the <code>RandomGeneratorWrapper</code> class to generate pseudorandom numbers and shuffle lists.</p>
<ul>
<li><p>The following methods can be used to generate random numbers of different types:</p>
<ul>
<li><p><code>PRNG.randomDouble()</code> returns a random double between 0 (included) and 1 (excluded).</p></li>
<li><p><code>PRNG.randomDouble(double lowerBound, double higherBound)</code> returns a random double within the given range.</p></li>
<li><p><code>PRNG.randomAngle()</code> returns a random angle between -pi (included) and pi (excluded).</p></li>
<li><p><code>PRNG.randomBoolean()</code> returns a random boolean.</p></li>
<li><p><code>PRNG.randomInt(int bound)</code> returns a random integer.</p></li>
<li><p><code>PRNG.randomGaussian()</code> returns a random double between 0 and 1 following a Gaussian.</p></li>
</ul></li>
<li><p>The <code>PRNG.shuffle(List&lt;?&gt; l)</code> method can be used to shuffle a list.</p></li>
<li><p>The random number generator algorithm used by default is <a href="https://en.wikipedia.org/wiki/Xoroshiro128%2B">xoroshiro128+</a> but it is possible to change it via the <code>PRNG.set()</code> method. There are various ways use it.</p>
<ul>
<li><p>The simplest one is to use the algorithms shipped with Similar2Logo:</p>
<ul>
<li><p><code>PRNG.set(new RandomGeneratorWrapper(RandomGeneratorWrapper.XORO))</code> to use <a href="https://en.wikipedia.org/wiki/Xoroshiro128%2B">xoroshiro128+</a>,</p></li>
<li><p><code>PRNG.set(new RandomGeneratorWrapper(RandomGeneratorWrapper.XOR))</code> to use <a href="https://en.wikipedia.org/wiki/Xorshift">xorshift128+</a>,</p></li>
<li><p><code>PRNG.set(new RandomGeneratorWrapper(RandomGeneratorWrapper.LIGHT))</code> to use <a href="http://xoroshiro.di.unimi.it/splitmix64.c">SplitMix64</a>,</p></li>
<li><p><code>PRNG.set(new RandomGeneratorWrapper(RandomGeneratorWrapper.MT_64))</code> to use <a href="https://en.wikipedia.org/wiki/Mersenne_Twister">MT19937-64 (Mersenne Twister)</a>,</p></li>
<li><p><code>PRNG.set(new RandomGeneratorWrapper(RandomGeneratorWrapper.WELL_1024))</code> to use <a href="https://en.wikipedia.org/wiki/Well_equidistributed_long-period_linear">WELL_1024</a>,</p></li>
<li><p><code>PRNG.set(new RandomGeneratorWrapper(RandomGeneratorWrapper.PCG))</code> to use <a href="http://www.pcg-random.org">PCG</a>,</p></li>
<li><p><code>PRNG.set(new RandomGeneratorWrapper(RandomGeneratorWrapper.JDK))</code> to use <a href="https://en.wikipedia.org/wiki/Linear_congruential_generator">JDK implemetation of LCG</a>.</p></li>
</ul></li>
<li><p>By default, the seed of the random number generator is generated using a <a href="https://docs.oracle.com/javase/8/docs/api/java/security/SecureRandom.html">SecureRandom</a> instance. To set a given seed, use, e.g., <code>PRNG.set(new RandomGeneratorWrapper(RandomGeneratorWrapper.XORO, 21))</code>.</p></li>
<li><p>If the random number generator is used in a multithreaded context it must be synchronized. It is done this way: <code>PRNG.set(new RandomGeneratorWrapper(RandomGeneratorWrapper.XORO, true))</code> or with a given seed: <code>PRNG.set(new RandomGeneratorWrapper(RandomGeneratorWrapper.XORO, 21, true))</code>. Note: using a random number generator in a multithreaded context leads to non replicable experiments.</p></li>
<li><p>You can use other random number generators, since they are defined in a class that extends <code>java.util.Random</code> or implements <code>org.apache.commons.math3.random.RandomGenerator</code>. E.g., <code>PRNG.set(new RandomGeneratorWrapper(new Well512a()))</code>. To use it in a multithreaded context: <code>PRNG.set(new RandomGeneratorWrapper(new Well512a(), true))</code>.</p></li>
</ul></li>
</ul></li>
<li><p>The <strong>parameters of the simulation</strong>, extending the class <code>LogoSimulationParameters</code>.</p></li>
<li><p>An <strong>environment</strong>. By default it is a 2D grid discretized into patches on which <strong>turtles</strong> (i.e., Similar2Logo agents), <strong>marks</strong> (i.e., passive objects) and <a href="https://en.wikipedia.org/wiki/Pheromone"><strong>pheromone fields</strong></a> are located and interact. It is implemented by the <code>LogoEnvPLS</code> class. Following the influences/reaction model, the environment has its own dynamics, which means that it can emit influences. By default, the environment emits 2 influences at each step:</p>
<ul>
<li><p><code>AgentPositionUpdate</code> which updates the position of turtles according to their dynamics (speed, acceleration and direction),</p></li>
<li><p><code>PheromoneFieldUpdate</code> which updates the pheromone fields.</p></li>
</ul></li>
<li><p><strong>Turtle models</strong>. In Similar2Logo, following the IRM4S model, a turtle has</p>
<ul>
<li><p>A <strong>public state</strong> (i.e., that can be perceived by other agents), defined by a class that inherits from <code>TurtlePLSInLogo</code>.</p></li>
<li><p>A <strong>perception model</strong>. 2 perceptions models are shipped with Similar2Logo: <code>ConeBasedPerceptionModel</code> (a cone based perception model) and <code>EmptyPerceptionModel</code> (a model that perceives nothing), but you can define your own perception model if needed.</p></li>
<li><p>A <strong>decision model</strong> that will defines how a turtle produces influences according to its state and perceptions. It is implemented in a class that inherits from <code>AbstractAgtDecisionModel</code>.</p></li>
<li><p>Possibly, a <strong>hidden state</strong> (i.e., that cannot be perceived by other agents) that inherits from <code>AbstractLocalStateOfAgent</code>.</p></li>
</ul></li>
<li><p>A set of <strong>influences</strong> that a turtle can emit. By default, the following influences can be used, but you may define your own influences if needed:</p>
<ul>
<li><p><code>ChangeAcceleration</code>: an influence that aims at changing the acceleration of a turtle.</p></li>
<li><p><code>ChangeDirection</code>: an influence that aims at changing the direction of a turtle.</p></li>
<li><p><code>ChangePosition</code>: an influence that aims at changing the position of a turtle.</p></li>
<li><p><code>ChangeSpeed</code>: an influence that aims at changing the speed of a turtle.</p></li>
<li><p><code>DropMark</code>: an influence that aims at dropping a mark at a given location.</p></li>
<li><p><code>EmitPheromone</code>: an influence that aims at emitting a pheromone at given location.</p></li>
<li><p><code>RemoveMark</code>: an influence that aims at removing a mark from the environment.</p></li>
<li><p><code>RemoveMarks</code>: an influence that aims at removing marks from the environment.</p></li>
<li><p><code>Stop</code>: an influence that aims at stopping a turtle.</p></li>
<li><p><code>SystemInfluenceAddAgent</code>: Adds a turtle to the simulation.</p></li>
<li><p><code>SystemInfluenceRemoveAgent</code>: Removes a turtle from the simulation.</p></li>
</ul></li>
<li><p>A <strong>reaction model</strong> which describes how influences are handled to compute the next simulation state. A default reaction model is implemented in <code>LogoDefaultReactionModel</code>, but you may define your own reaction model if needed.</p></li>
<li><p>A <strong>simulation model</strong> that defines the initial state of the simulation. It is implemented in a class that inherits from <code>AbstractLogoSimulationModel</code>.</p></li>
<li><p>A <strong>simulation engine</strong>, i.e., the algorithm that execute the simulation. By default, the mono-threaded engine of Similar is used.</p></li>
<li><p>A set of <strong>probes</strong>, attached to the engine, that monitor the simulation. By default the following probes are launched:</p>
<ul>
<li><p><code>Slf4jExecutionTracker</code>, that tracks the execution of the simulation and prints notification messages,</p></li>
<li><p><code>Slf4jExceptionPrinter</code>, that prints the trace of an exception that was thrown during the execution of the simulation,</p></li>
<li><p><code>JSONProbe</code>, that send information about the location of turtles, marks and phermones in JSON format to a websocket.</p></li>
<li><p><code>InteractiveSimulationProbe</code>, that allows to pause and resume the simulation.</p></li>
</ul></li>
<li><p>A <strong>web server</strong> that serves as an interface between the web GUI and the engine. Since the version 0.9 of Similar2Logo, the class <code>Similar2LogoWebRunner</code> is used to control and configure it.</p></li>
</ul>
<p>The easiest way to understand how to develop a simulation is to have a look at the <a href="#jexamples">Java</a>, <a href="#gexamples">Groovy</a> or <a href="#rexamples">Ruby</a> examples.</p>
<h2 id="java-examples"><a name="jexamples"></a> Java Examples</h2>
<p>In the following we comment the examples written in Java distributed with Similar2Logo. Each example introduces a specific feature.</p>
<ul>
<li><p><a href="#jpassive">A first example with a passive turtle</a></p></li>
<li><p><a href="#jboids">Adding a user-defined decision model to the turtles: The boids model</a></p></li>
<li><p><a href="#jturmite">Dealing with marks: the turmite model</a></p></li>
<li><p><a href="#jmultiturmite">Adding an interaction and a user-defined reaction model: The multiturmite model</a></p></li>
<li><p><a href="#jsegregation">Adding user-defined influence, reaction model and GUI: The segregation model</a></p></li>
<li><p><a href="#jheatbugs">Adding a hidden state to the turtles and a pheromone field: The heatbugs model</a></p></li>
</ul>
<h3 id="a-first-example-with-a-passive-turtle"><a name="jpassive"></a> A first example with a passive turtle</h3>
<p>First we consider a simple example with a single passive agent. The example source code is located in the package <code>fr.univ_artois.lgi2a.similar2logo.examples.passive</code>. It contains 3 classes:</p>
<ul>
<li><p><code>PassiveTurtleSimulationParameters</code>, that defines the parameters of the model. This class inherits from <code>LogoSimulationParameters</code>.</p></li>
<li><p><code>PassiveTurtleSimulationModel</code>, that defines the simulation model, i.e, the initial state of the simulation. This class inherits from <code>AbstractLogoSimulationModel</code>.</p></li>
<li><p><code>PassiveTurtleSimulationMain</code>, the main class of the simulation.</p></li>
</ul>
<h4 id="model-parameters">Model parameters</h4>
<p>The class <code>LogoSimulationParameters</code> defines the generic parameters of a Logo-like simulation (environment size, topology, etc.).</p>
<p>The class <code>PassiveTurtleSimulationParameters</code> contains the parameters specific to this model.</p>
<pre><code>    @Parameter(
       name = &quot;initial x&quot;, 
       description = &quot;the initial position of the turtle on the x axis&quot;
    )
    public double initialX;
    
    @Parameter(
       name = &quot;initial y&quot;, 
       description = &quot;the initial position of the turtle on the y axis&quot;
    )
    public double initialY;
    
    @Parameter(
       name = &quot;initial speed&quot;, 
       description = &quot;the initial speed of the turtle&quot;
    )
    public double initialSpeed;
    
    @Parameter(
       name = &quot;initial acceleration&quot;, 
       description = &quot;the initial acceleration of the turtle&quot;
    )
    public double initialAcceleration;
    
    @Parameter(
       name = &quot;initial direction&quot;, 
       description = &quot;the initial direction of the turtle&quot;
    )
    public double initialDirection;
</code></pre>
<p>Note that each parameter is prefixed with the <code>@Parameter</code> annotation. This annotation is mandatory to be able to change the value of the parameters in the GUI.</p>
<p>The default constructor of the <code>PassiveTurtleSimulationParameters</code> defines the default values of the simulation parameters.</p>
<pre><code>    public PassiveTurtleSimulationParameters() {
        super();
        this.initialX = 10;
        this.initialY = 10;
        this.initialAcceleration = 0;
        this.initialDirection = LogoEnvPLS.NORTH;
        this.initialSpeed = 0.1;
        this.xTorus = true;
        this.yTorus = true;
        this.gridHeight = 20;
        this.gridWidth = 20;
        this.initialTime = new SimulationTimeStamp( 0 );
        this.finalTime = new SimulationTimeStamp( 3000 );
    }</code></pre>
<h4 id="the-simulation-model">The simulation model</h4>
<p>The class <a href="http://www.lgi2a.univ-artois.fr/~morvan/similar2logo/docs/api/fr/univ_artois/lgi2a/similar2logo/kernel/initializations/AbstractLogoSimulationModel.html">AbstractLogoSimulationModel</a> defines a generic simulation model of a Similar2Logo simulation. We must implement the <code>generateAgents</code> method to describe the initial state of our passive turtle.</p>
<pre><code>    protected AgentInitializationData generateAgents(
            ISimulationParameters parameters, Map&lt;LevelIdentifier, ILevel&gt; levels) {
        PassiveTurtleSimulationParameters castedParameters = (PassiveTurtleSimulationParameters) parameters;
        AgentInitializationData result = new AgentInitializationData();
        
        IAgent4Engine turtle = TurtleFactory.generate(
            new EmptyPerceptionModel(),
            new PassiveTurtleDecisionModel(),
            new AgentCategory(&quot;passive&quot;, TurtleAgentCategory.CATEGORY),
            castedParameters.initialDirection,
            castedParameters.initialSpeed,
            castedParameters.initialAcceleration,
            castedParameters.initialX,
            castedParameters.initialY
        );
        result.getAgents().add( turtle );
        return result;
    }
</code></pre>
<p>Note that it is not necessary to define any class related to our turtle. Since it is passive, we use a predefined decision model called <code>PassiveTurtleDecisionModel</code>.</p>
<p>Since the turtle does not need to perceive anything, as a perception module, we use the empty perception model <code>EmptyPerceptionModel</code>.</p>
<h4 id="the-main-class">The Main class</h4>
<p>In the main class, the simulation model is created and the HTML runner is launched and configured. Here, only the turtles are displayed.</p>
<p>Finally, the probe <code>RealTimeMatcherProbe</code> is added to the runner to slow down the simulation so that its execution speed matches a specific factor of N steps per second.</p>
<p>The <code>main</code> method contains the following code:</p>
<pre><code>        // Creation of the runner
        Similar2LogoWebRunner runner = new Similar2LogoWebRunner( );
        // Creation of the model
        AbstractLogoSimulationModel model = new PassiveTurtleSimulationModel( new PassiveTurtleSimulationParameters() );
        // Configuration of the runner
        runner.getConfig().setExportAgents( true );
        // Initialize the runner
        runner.initializeRunner( model );
        // Add other probes to the engine
        runner.addProbe(&quot;Real time matcher&quot;, new RealTimeMatcherProbe(20));
        // Open the GUI.
        runner.showView( );</code></pre>
<h3 id="adding-a-decision-module-to-the-turtles-the-boids-model"><a name="jboids"></a> Adding a decision module to the turtles: The boids model</h3>
<p>The <a href="https://en.wikipedia.org/wiki/Boids">boids</a> (bird-oid) model has been invented by <a href="https://en.wikipedia.org/wiki/Craig_Reynolds_(computer_graphics)">Graig Reynolds</a> in 1986 to simulate flocking behavior of birds. It is based on 3 principles:</p>
<ul>
<li><p>separation: boids tend to avoid other boids that are too close,</p></li>
<li><p>alignment: boids tend to align their velocity to boids that are not too close and not too far away,</p></li>
<li><p>cohesion: bois tend to move towards boids that are too far away.</p></li>
</ul>
<p>While these rules are essentially heuristic, they can be implemented defining three areas for each principle.</p>
<ul>
<li><p>Boids change their orientation to get away from other boids in the repulsion area,</p></li>
<li><p>Boids change their orientation and speed to match those of other boids in the orientation area,</p></li>
<li><p>Boids change their orientation to get to other boids in the attraction area.</p></li>
</ul>
<p>An implementation of such model is located in the package <code>fr.univ_artois.lgi2a.similar2logo.examples.boids</code>.</p>
<p>The model itself is defined in the package <code>fr.univ_artois.lgi2a.similar2logo.examples.boids.model</code> which contains 2 classes:</p>
<ul>
<li><p><code>BoidsSimulationParameters</code>, that defines the parameters of the model. This class inherits from <code>LogoSimulationParameters</code>,</p></li>
<li><p><code>BoidDecisionModel</code>, that defines the decision model of the boids. This class inherits from <code>AbstractAgtDecisionModel</code>.</p></li>
</ul>
<p>The simulation model and main class are located in the main package.</p>
<h4 id="model-parameters-1">Model parameters</h4>
<p>The <code>BoidsSimulationParameters</code> class contains the following parameters:</p>
<pre><code>    @Parameter(
       name = &quot;repulsion distance&quot;, 
       description = &quot;the repulsion distance&quot;
    )
    public double repulsionDistance;
    
    @Parameter(
       name = &quot;attraction distance&quot;, 
       description = &quot;the attraction distance&quot;
    )
    public double attractionDistance;
    
    @Parameter(
       name = &quot;orientation distance&quot;, 
       description = &quot;the orientation distance&quot;
    )
    public double orientationDistance;
    
    @Parameter(
       name = &quot;repulsion weight&quot;, 
       description = &quot;the repulsion weight&quot;
    )
    public double repulsionWeight;
    

    @Parameter(
       name = &quot;orientation weight&quot;, 
       description = &quot;the orientation weight&quot;
    )
    public double orientationWeight;

    @Parameter(
       name = &quot;attraction weight&quot;, 
       description = &quot;the attraction weight&quot;
    )
    public double attractionWeight;
    
    @Parameter(
       name = &quot;maximal initial speed&quot;, 
       description = &quot;the maximal initial speed of boids&quot;
    )
    public double maxInitialSpeed;
    
    @Parameter(
        name = &quot;minimal initial speed&quot;, 
        description = &quot;the minimal initial speed of boids&quot;
    )
    public double minInitialSpeed;
    
    @Parameter(
       name = &quot;perception angle&quot;, 
       description = &quot;the perception angle of the boids in rad&quot;
    )
    public double perceptionAngle;
    
    @Parameter(
       name = &quot;number of agents&quot;, 
       description = &quot;the number of agents in the simulation&quot;
    )
    public int nbOfAgents;

    @Parameter(
       name = &quot;max angular speed&quot;, 
       description = &quot;the maximal angular speed of the boids in rad/step&quot;
    )
    public double maxAngle;</code></pre>
<h4 id="the-behavior-of-the-boids">The behavior of the boids</h4>
<p>The decision model consists in changing the direction and speed of the boids according to the previously described rules. To define a decision model, the modeler must define a class that extends <code>AbstractAgtDecisionModel</code> and implement the <code>decide</code> method.</p>
<pre><code>    @Override
    public void decide(SimulationTimeStamp timeLowerBound,
        SimulationTimeStamp timeUpperBound,
        IGlobalState globalState,
        ILocalStateOfAgent publicLocalState,
        ILocalStateOfAgent privateLocalState,
        IPerceivedData perceivedData,
        InfluencesMap producedInfluences
    ) {
        
        TurtlePLSInLogo castedPublicLocalState = (TurtlePLSInLogo) publicLocalState;
        TurtlePerceivedData castedPerceivedData = (TurtlePerceivedData) perceivedData;
        
        if(!castedPerceivedData.getTurtles().isEmpty()) {
            double orientationSpeed = 0;
            int nbOfTurtlesInOrientationArea = 0;
            MeanAngle meanAngle = new MeanAngle();
            for (LocalPerceivedData&lt;TurtlePLSInLogo&gt; perceivedTurtle : castedPerceivedData.getTurtles()) {
                if (perceivedTurtle.getDistanceTo() &lt;= this.parameters.repulsionDistance) {
                    meanAngle.add(
                        castedPublicLocalState.getDirection()- perceivedTurtle.getDirectionTo(),
                        parameters.repulsionWeight
                    );
                } else if (perceivedTurtle.getDistanceTo() &lt;= this.parameters.orientationDistance) {
                    meanAngle.add(
                        perceivedTurtle.getContent().getDirection() - castedPublicLocalState.getDirection(),
                        parameters.orientationWeight
                    );
                    orientationSpeed+=perceivedTurtle.getContent().getSpeed() - castedPublicLocalState.getSpeed();
                    nbOfTurtlesInOrientationArea++;
                } else if (perceivedTurtle.getDistanceTo() &lt;= this.parameters.attractionDistance){
                    meanAngle.add(
                        perceivedTurtle.getDirectionTo()- castedPublicLocalState.getDirection(),
                        parameters.attractionWeight
                    );
                }
            }
            double dd = meanAngle.value();
            if (!MathUtil.areEqual(dd, 0)) {
                if(dd &gt; parameters.maxAngle) {
                    dd = parameters.maxAngle;
                }else if(dd&lt;-parameters.maxAngle) {
                    dd = -parameters.maxAngle;
                }
                producedInfluences.add(
                    new ChangeDirection(
                        timeLowerBound,
                        timeUpperBound,
                        dd,
                        castedPublicLocalState
                    )
                );
            }
            if (nbOfTurtlesInOrientationArea &gt; 0) {
                orientationSpeed /= nbOfTurtlesInOrientationArea;
                producedInfluences.add(
                    new ChangeSpeed(
                        timeLowerBound,         
                        timeUpperBound,
                        orientationSpeed,
                        castedPublicLocalState
                    )
                );
            }
        }
    }   
</code></pre>
<h4 id="the-simulation-model-1">The simulation model</h4>
<p>In the simulation model defined in our example, boids are initially randomly located in the environment with a random orientation and speed.</p>
<pre><code>    /**
     * {@inheritDoc}
     */
    @Override
    protected AgentInitializationData generateAgents(
        ISimulationParameters parameters, Map&lt;LevelIdentifier, ILevel&gt; levels
    ) {
        BoidsSimulationParameters castedParameters = (BoidsSimulationParameters) parameters;
        AgentInitializationData result = new AgentInitializationData();
        for(int i = 0; i &lt; castedParameters.nbOfAgents; i++) {
            result.getAgents().add(generateBoid(castedParameters));
        }
        return result;
    }
    
    /**
     * @param p The parameters of the simulation model.
     * @return a new boid located at the center of the grid.
     */
    private static IAgent4Engine generateBoid(BoidsSimulationParameters p) {
        return TurtleFactory.generate(
            new ConeBasedPerceptionModel(
                p.attractionDistance,p.perceptionAngle,true,false,false
            ),
            new BoidDecisionModel(p),
            new AgentCategory(&quot;b&quot;, TurtleAgentCategory.CATEGORY),
            PRNG.randomAngle(),
            p.minInitialSpeed + PRNG.randomDouble()*(
                p.maxInitialSpeed-p.minInitialSpeed
            ),
            0,
            PRNG.randomDouble()*p.gridWidth,
            PRNG.randomDouble()*p.gridHeight
        );
    }</code></pre>
<h4 id="the-main-class-1">The main class</h4>
<p>In the main class, such as in the previous example, the simulation model is created and the HTML runner is launched and configured. The <code>main</code> method contains the following code:</p>
<pre><code>        // Creation of the runner
        Similar2LogoWebRunner runner = new Similar2LogoWebRunner( );
        // Creation of the model
        AbstractLogoSimulationModel model = new BoidsSimulationModel( new BoidsSimulationParameters() );
        // Configuration of the runner
        runner.getConfig().setExportAgents( true );
        // Initialize the runner
        runner.initializeRunner( model );
        // Open the GUI.
        runner.showView( );</code></pre>
<p>The main class is very similar to the previous example. Only the simulation model has been changed.</p>
<h3 id="dealing-with-marks-the-turmite-model"><a name="jturmite"></a> Dealing with marks: the turmite model</h3>
<p>The <a href="https://en.wikipedia.org/wiki/Langton&#39;s_ant">turmite model</a>, developed by <a href="https://en.wikipedia.org/wiki/Christopher_Langton">Christopher Langton</a> in 1986, is a very simple mono-agent model that exhibits an emergent behavior. It is based on 2 rules:</p>
<ul>
<li><p>If the turmite is on a patch that does not contain a mark, it turns right, drops a mark, and moves forward,</p></li>
<li><p>If the turmite is on a patch that contains a mark, it turns left, removes the mark, and moves forward.</p></li>
</ul>
<p>The example source code is located in the package <code>fr.univ_artois.lgi2a.similar2logo.examples.turmite</code>. It contains 3 classes:</p>
<ul>
<li><p><code>TurmiteDecisionModel</code> that defines the decision model of the turmites,</p></li>
<li><p><code>TurmiteSimulationModel</code> that defines the simulation model,</p></li>
<li><p><code>TurmiteSimulationMain</code>, the main class of the simulation.</p></li>
</ul>
<h4 id="the-decision-model">The decision model</h4>
<p>The decision model implements the above described rules :</p>
<pre><code>    @Override
    public void decide(SimulationTimeStamp timeLowerBound,
            SimulationTimeStamp timeUpperBound, IGlobalState globalState,
            ILocalStateOfAgent publicLocalState,
            ILocalStateOfAgent privateLocalState, IPerceivedData perceivedData,
            InfluencesMap producedInfluences) {
        TurtlePLSInLogo castedPublicLocalState = (TurtlePLSInLogo) publicLocalState;
        TurtlePerceivedData castedPerceivedData = (TurtlePerceivedData) perceivedData;
        
        if(castedPerceivedData.getMarks().isEmpty()) {
            producedInfluences.add(
                new ChangeDirection(
                    timeLowerBound,
                    timeUpperBound,
                    Math.PI/2,
                    castedPublicLocalState
                )
            );
            producedInfluences.add(
                new DropMark(
                    timeLowerBound,
                    timeUpperBound,
                    new Mark&lt;Object&gt;(
                        (Point2D) castedPublicLocalState.getLocation().clone(),
                        null
                    )
                )
            );
        } else {
            producedInfluences.add(
                new ChangeDirection(
                    timeLowerBound,
                    timeUpperBound,
                    -Math.PI/2,
                    castedPublicLocalState
                )
            );
            
            producedInfluences.add(
                new RemoveMark(
                    timeLowerBound,
                    timeUpperBound,
                    castedPerceivedData.getMarks().iterator().next().getContent()
                )
            );
        }
        

    }</code></pre>
<h4 id="the-simulation-model-2">The simulation model</h4>
<p>The simulation model generates a turmite heading north at the location 10.5,10.5 with a speed of 1 and an acceleration of 0:</p>
<pre><code>    @Override
    protected AgentInitializationData generateAgents(
            ISimulationParameters simulationParameters,
            Map&lt;LevelIdentifier, ILevel&gt; levels) {
        AgentInitializationData result = new AgentInitializationData(); 
        IAgent4Engine turtle = TurtleFactory.generate(
            new ConeBasedPerceptionModel(0, 2*Math.PI, false, true, false),
            new TurmiteDecisionModel(),
            new AgentCategory(&quot;turmite&quot;, TurtleAgentCategory.CATEGORY),
            LogoEnvPLS.NORTH,
            1,
            0,
            10.5,
            10.5
        );
        result.getAgents().add( turtle );
        return result;  
    }</code></pre>
<h4 id="the-main-class-2">The main class</h4>
<p>In the main class, such as in the previous example, the simulation model is created and the HTML runner is launched and configured. The <code>main</code> method contains the following code:</p>
<pre><code>        //Launch the HTML runner
        Similar2LogoWebRunner runner = new Similar2LogoWebRunner( );
        runner.getConfig().setExportAgents( true );
        runner.getConfig().setExportMarks( true );
        runner.initializeRunner( new TurmiteSimulationModel(parameters) );
        runner.addProbe(&quot;Real time matcher&quot;, new RealTimeMatcherProbe(20));
        runner.showView( );</code></pre>
<p>The main difference with the previous example is that in this case we want to observe turtles and marks.</p>
<h3 id="adding-an-interaction-and-a-user-defined-reaction-model-the-multiturmite-model"><a name="jmultiturmite"></a> Adding an interaction and a user-defined reaction model: The multiturmite model</h3>
<p>The goal of this example is to implement the multiturmite model proposed by <a href="http://www.loria.fr/~fates/">N. Fatès</a> and <a href="http://www.loria.fr/~chevrier/">V. Chevrier</a> in <a href="http://www.ifaamas.org/Proceedings/aamas2010/pdf/01%20Full%20Papers/11_04_FP_0210.pdf">this paper</a>. It extends the traditional <a href="http://en.wikipedia.org/wiki/Langton%27s_ant">Langton’s ant model</a> by specifying what happens when conflicting influences (removing or dropping a mark to the same location) are detected. The following policy is applied:</p>
<ul>
<li><p>if the parameter <code>dropMark</code> is <code>true</code>, the dropping influence takes precedent over the removing one and reciprocally.</p></li>
<li><p>if the parameter <code>removeDirectionChange</code> is <code>true</code>, direction changes are not taken into account.</p></li>
</ul>
<p>It allows to define 4 different reaction models according to these parameters.</p>
<p>This model is located in the <code>fr.univ_artois.lgi2a.similar2logo.examples.multiturmite</code> package and contains at least 5 classes:</p>
<ul>
<li><p><code>MultiTurmiteSimulationParameters</code>, that contains the parameters of the model,</p></li>
<li><p><code>TurmiteInteraction</code>, that defines an interaction between multiple turmites,</p></li>
<li><p><code>MultiTurmiteReactionModel</code>, that extends <code>LogoDefaultReactionModel</code> and defines the reaction model, i.e., the way influences are handled,</p></li>
<li><p><code>MultiTurmiteSimulationModel</code> that defines the simulation model,</p></li>
<li><p>Different main classes that define a specific initial configuration of the simulation, in our case, based on the ones described by <a href="http://www.loria.fr/~fates/">N. Fatès</a> and <a href="http://www.loria.fr/~chevrier/">V. Chevrier</a> in <a href="http://www.ifaamas.org/Proceedings/aamas2010/pdf/01%20Full%20Papers/11_04_FP_0210.pdf">their paper</a>.</p></li>
</ul>
<h4 id="model-parameters-2">Model parameters</h4>
<p>The model parameters are defined in the class <code>MultiTurmiteSimulationParameters</code>. It defines how influences are handled according to the previously defined policy, the number of turmites and their initial locations.</p>
<pre><code>    @Parameter(
       name = &quot;remove direction change&quot;, 
       description = &quot;if checked, direction changes are not taken into account when two turtles want to modify the same patch&quot;
    )
    public boolean removeDirectionChange;
    
    @Parameter(
       name = &quot;inverse mark update&quot;, 
       description = &quot;if checked, the output of turtle actions is inversed when two turtles want to modify the same patch&quot;
    )
    public boolean inverseMarkUpdate;
    
    @Parameter(
       name = &quot;number of turmites&quot;, 
       description = &quot;the  number of turmites in the environment&quot;
    )
    public int nbOfTurmites;
    
    @Parameter(
       name = &quot;initial locations&quot;, 
       description = &quot;the  initial locations of turmites&quot;
    )
    public List&lt;Point2D&gt; initialLocations;
    
    @Parameter(
       name = &quot;initial directions&quot;, 
       description = &quot;the initial directions of turmites&quot;
    )
    public List&lt;Double&gt; initialDirections;</code></pre>
<h4 id="the-reaction-model">The reaction model</h4>
<p>In the previous example, the influence management relies on the default reaction model defined in the class <code>LogoDefaultReactionModel</code>. Now, we want to handle some influences manually. To do so, we have to define a class <code>MultiTurmiteReactionModel</code> that inherits from <code>LogoDefaultReactionModel</code>. This class has one attribute: the parameters of the simulation.</p>
<pre><code>    private MultiTurmiteSimulationParameters parameters
</code></pre>
<p>What we have to do is to change the behavior of the <code>makeRegularReaction</code> method. A generic stub of a specific reaction model is given below:</p>
<pre><code>public void makeRegularReaction(SimulationTimeStamp transitoryTimeMin,
            SimulationTimeStamp transitoryTimeMax,
            ConsistentPublicLocalDynamicState consistentState,
            Set&lt;IInfluence&gt; regularInfluencesOftransitoryStateDynamics,
            InfluencesMap remainingInfluences) {
        Set&lt;IInfluence&gt; nonSpecificInfluences = new LinkedHashSet&lt;IInfluence&gt;();


        //Management of specific influences
        
        super.makeRegularReaction(transitoryTimeMin, transitoryTimeMax, consistentState, nonSpecificInfluences, remainingInfluences);
    }</code></pre>
<p>The idea is to identify the influences that do not trigger a generic reaction and manage them separately. Non specific influences are handled by the regular reaction.</p>
<p>In this case, specific influences represents collisions between turtle decisions. We define a class <code>TurmiteInteraction</code> that explicitly represent possible collisions for each location.</p>
<pre><code>public class TurmiteInteraction {

    private Set&lt;DropMark&gt; dropMarks ;
    private Set&lt;RemoveMark&gt; removeMarks;
    private Set&lt;ChangeDirection&gt; changeDirections;
    
    /**
     * 
     */
    public TurmiteInteraction() {
        dropMarks = new LinkedHashSet&lt;DropMark&gt;();
        removeMarks = new LinkedHashSet&lt;RemoveMark&gt;();
        changeDirections = new LinkedHashSet&lt;ChangeDirection&gt;();
    }
    /**
     * 
     * @return &lt;code&gt;true&lt;/code&gt; if there is a collision
     */
    public boolean isColliding() {
        return removeMarks.size() &gt; 1|| dropMarks.size() &gt; 1;
    }

    //Getters and setters
}</code></pre>
<p>Then, it is easy to implement the reaction model whether the influences are colliding or not:</p>
<pre><code>    @Override
    public void makeRegularReaction(SimulationTimeStamp transitoryTimeMin,
            SimulationTimeStamp transitoryTimeMax,
            ConsistentPublicLocalDynamicState consistentState,
            Set&lt;IInfluence&gt; regularInfluencesOftransitoryStateDynamics,
            InfluencesMap remainingInfluences) {
        Set&lt;IInfluence&gt; nonSpecificInfluences = new LinkedHashSet&lt;IInfluence&gt;();
        Map&lt;Point2D,TurmiteInteraction&gt; collisions = new LinkedHashMap&lt;Point2D,TurmiteInteraction&gt;();
        
        //Organize influences by location and type
        for(IInfluence influence : regularInfluencesOftransitoryStateDynamics) {
            if(influence.getCategory().equals(DropMark.CATEGORY)) {
                DropMark castedDropInfluence = (DropMark) influence;
                if(!collisions.containsKey(castedDropInfluence.getMark().getLocation())) {
                    collisions.put(
                        castedDropInfluence.getMark().getLocation(),
                        new TurmiteInteraction()
                    );
                } 
                collisions.get(castedDropInfluence.getMark().getLocation()).getDropMarks().add(castedDropInfluence);
    
            } else if(influence.getCategory().equals(RemoveMark.CATEGORY)) {
                RemoveMark castedRemoveInfluence = (RemoveMark) influence;
                if(!collisions.containsKey(castedRemoveInfluence.getMark().getLocation())) {
                    collisions.put(
                        castedRemoveInfluence.getMark().getLocation(),
                        new TurmiteInteraction()
                    );
                }
                collisions.get(castedRemoveInfluence.getMark().getLocation()).getRemoveMarks().add(castedRemoveInfluence);
            } else if(influence.getCategory().equals(ChangeDirection.CATEGORY)) {
                ChangeDirection castedChangeDirectionInfluence = (ChangeDirection) influence;
                if(!collisions.containsKey(castedChangeDirectionInfluence.getTarget().getLocation())) {
                    collisions.put(
                        castedChangeDirectionInfluence.getTarget().getLocation(),
                        new TurmiteInteraction()
                    );
                }
                collisions.get(castedChangeDirectionInfluence.getTarget().getLocation()).getChangeDirections().add(castedChangeDirectionInfluence);
            } else {
                nonSpecificInfluences.add(influence);
            }
        }
    
        for(Map.Entry&lt;Point2D, TurmiteInteraction&gt; collision : collisions.entrySet()) {
            if(collision.getValue().isColliding()) {
                if(!collision.getValue().getDropMarks().isEmpty() &amp;&amp; !this.parameters.inverseMarkUpdate) {
                    nonSpecificInfluences.add(
                        collision.getValue().getDropMarks().iterator().next()
                    );
                } if(!collision.getValue().getRemoveMarks().isEmpty() &amp;&amp; !this.parameters.inverseMarkUpdate)  {
                    nonSpecificInfluences.add(
                        collision.getValue().getRemoveMarks().iterator().next()
                    );
                }
                
                if(!this.parameters.removeDirectionChange) {
                    nonSpecificInfluences.addAll(collision.getValue().getChangeDirections());
                }
            } else {
                nonSpecificInfluences.addAll(collision.getValue().getChangeDirections());
                if(!collision.getValue().getDropMarks().isEmpty()) {
                    nonSpecificInfluences.add(collision.getValue().getDropMarks().iterator().next());
                }
                if(!collision.getValue().getRemoveMarks().isEmpty()) {
                    nonSpecificInfluences.add(collision.getValue().getRemoveMarks().iterator().next());
                }
            }
        }
        
        super.makeRegularReaction(transitoryTimeMin, transitoryTimeMax, consistentState, nonSpecificInfluences, remainingInfluences);
    }</code></pre>
<h4 id="the-simulation-model-3">The simulation model</h4>
<p>The simulation model of this example is located in the class <code>MultiTurmiteSimulationModel</code>.</p>
<p>Such as in the previous example, we have to redefine the method <code>generateAgents</code> to specify the initial population of agents of the simulation:</p>
<pre><code>@Override
    protected AgentInitializationData generateAgents(
            ISimulationParameters simulationParameters,
            Map&lt;LevelIdentifier, ILevel&gt; levels) {
        AgentInitializationData result = new AgentInitializationData(); 
        MultiTurmiteSimulationParameters castedSimulationParameters = (MultiTurmiteSimulationParameters) simulationParameters;
        if(castedSimulationParameters.initialLocations.isEmpty()) {
            for(int i = 0; i &lt; castedSimulationParameters.nbOfTurmites; i++) {
                IAgent4Engine turtle = TurtleFactory.generate(
                    new ConeBasedPerceptionModel(0, 2*Math.PI, false, true, false),
                    new TurmiteDecisionModel(),
                    new AgentCategory(&quot;turmite&quot;, TurtleAgentCategory.CATEGORY),
                    MultiTurmiteSimulationModel.randomDirection(),
                    1,
                    0,
                    Math.floor(PRNG.randomDouble()*castedSimulationParameters.gridWidth),
                    Math.floor(PRNG.randomDouble()*castedSimulationParameters.gridHeight)
                );
                result.getAgents().add( turtle );
            }
        } else {
            if(
                castedSimulationParameters.nbOfTurmites != castedSimulationParameters.initialDirections.size() ||
                castedSimulationParameters.nbOfTurmites != castedSimulationParameters.initialLocations.size()
            ) {
                throw new UnsupportedOperationException(&quot;Inital locations and directions must be specified for each turmite&quot;);
            }
            for(int i = 0; i &lt; castedSimulationParameters.nbOfTurmites; i++) {
                IAgent4Engine turtle = TurtleFactory.generate(
                    new ConeBasedPerceptionModel(0, 2*Math.PI, false, true, false),
                    new TurmiteDecisionModel(),
                    new AgentCategory(&quot;turmite&quot;, TurtleAgentCategory.CATEGORY),
                    castedSimulationParameters.initialDirections.get(i),
                    1,
                    0,
                    castedSimulationParameters.initialLocations.get(i).getX(),
                    castedSimulationParameters.initialLocations.get(i).getY()
                );
                result.getAgents().add( turtle );
            }
        }
        return result;  
    }
    </code></pre>
<p>However, contrary to the previous examples, we have to redefine the method <code>generateLevels</code> to specify the reaction model we use:</p>
<pre><code>    protected List&lt;ILevel&gt; generateLevels(
            ISimulationParameters simulationParameters) {
        MultiTurmiteSimulationParameters castedSimulationParameters = (MultiTurmiteSimulationParameters) simulationParameters;
        ExtendedLevel logo = new ExtendedLevel(
                castedSimulationParameters.getInitialTime(), 
                LogoSimulationLevelList.LOGO, 
                new PeriodicTimeModel( 
                    1, 
                    0, 
                    castedSimulationParameters.getInitialTime()
                ),
                new MultiTurmiteReactionModel(castedSimulationParameters)
            );
        List&lt;ILevel&gt; levelList = new LinkedList&lt;ILevel&gt;();
        levelList.add(logo);
        return levelList;
    }</code></pre>
<h4 id="the-main-class-3">The Main class</h4>
<p>The main class contains the following code:</p>
<pre><code>        // Creation of the runner
        Similar2LogoWebRunner runner = new Similar2LogoWebRunner( );
        
        // Definition of the parameters
        MultiTurmiteSimulationParameters parameters = new MultiTurmiteSimulationParameters();
        parameters.initialTime = new SimulationTimeStamp( 0 );
        parameters.finalTime = new SimulationTimeStamp( 100000 );
        parameters.xTorus = true;
        parameters.yTorus = true;
        parameters.gridHeight = 50;
        parameters.gridWidth = 50;
        parameters.nbOfTurmites = 2;
        parameters.inverseMarkUpdate = false;
        parameters.removeDirectionChange = false;
        //Create a specific instance
        parameters.initialLocations.add(new Point2D.Double(Math.floor(parameters.gridWidth/2),Math.floor(parameters.gridHeight/2)));
        parameters.initialDirections.add(LogoEnvPLS.NORTH);
        parameters.initialLocations.add(new Point2D.Double(Math.floor(parameters.gridWidth/2),Math.floor(parameters.gridHeight/2) +1));
        parameters.initialDirections.add(LogoEnvPLS.NORTH);
        
        // Creation of the model
        AbstractLogoSimulationModel model = new MultiTurmiteSimulationModel( parameters );
        // Configuration of the runner
        runner.getConfig().setExportAgents( true );
        runner.getConfig().setExportMarks( true );
        // Initialize the runner
        runner.initializeRunner( model );
        // Add other probes to the engine
        runner.addProbe(&quot;Real time matcher&quot;, new RealTimeMatcherProbe(20));
        // Open the GUI.
        runner.showView( );</code></pre>
<p>In this case, we create a specific instance of the multiturmite model with 2 turmites. This configuration described by <a href="http://www.loria.fr/~fates/">N. Fatès</a> and <a href="http://www.loria.fr/~chevrier/">V. Chevrier</a> in <a href="http://www.ifaamas.org/Proceedings/aamas2010/pdf/01%20Full%20Papers/11_04_FP_0210.pdf">their paper</a> produces interesting and distinctive emergent behaviors according to the values of <code>dropMark</code> and <code>removeDirectionChange</code> parameters.</p>
<p>Such as in the previous example, we want to observe the turtles and the marks.</p>
<h3 id="adding-user-defined-influence-reaction-model-and-gui-the-segregation-model"><a name="jsegregation"></a> Adding user-defined influence, reaction model and GUI: The segregation model</h3>
<p>The segregation model has been proposed by <a href="https://en.wikipedia.org/wiki/Thomas_Schelling">Thomas Schelling</a> in 1971 in his famous paper <a href="https://www.stat.berkeley.edu/~aldous/157/Papers/Schelling_Seg_Models.pdf">Dynamic Models of Segregation</a>. The goal of this model is to show that segregation can occur even if it is not wanted by the agents.</p>
<p>In our implementation of this model, turtles are located in the grid and at each step, compute an happiness index based on the similarity of other agents in their neighborhood. If this index is below a value, called here similarity rate, the turtle wants to move to an other location.</p>
<p>The segregation simulation source code is located in the package <code>fr.univ_artois.lgi2a.similar2logo.examples.segregation</code>. It contains</p>
<ul>
<li><p>a <code>model</code> package that describes the model. It is composed of 4 classes</p>
<ul>
<li><p><code>SegregationSimulationParameters</code> that extends <code>LogoSimulationParameters</code>, that contains the parameters of the simulation.</p></li>
<li><p><code>Move</code> that extends <code>RegularInfluence</code>, representing a model-specific influence, emitted by an agent who wants to move to another location.</p></li>
<li><p><code>SegregationAgentDecisionModel</code> that extends <code>AbstractAgtDecisionModel</code>, representing the decision model of our turtles.</p></li>
<li><p><code>SegregationReactionModel</code> that extends <code>LogoDefaultReactionModel</code>, representing the model-specific reaction model. It defines how <code>Move</code> influences are handled.</p></li>
</ul></li>
<li><p>a class <code>SegregationSimulationModel</code> that extends <code>AbstractLogoSimulationModel</code>, representing the simulation model, i.e., the initial state of the simulation.</p></li>
<li><p>the main class of the simulation <code>SegregationSimulationMain</code>.</p></li>
<li><p>a HTML file <code>segregationgui.html</code>, that contains the GUI of the simulation.</p></li>
</ul>
<h4 id="model-parameters-3">Model parameters</h4>
<p>The model parameters are defined in the class <code>SegregationSimulationParameters</code>. It contains the following parameters:</p>
<pre><code>    @Parameter(
       name = &quot;similarity rate&quot;, 
       description = &quot;the rate of same-color turtles that each turtle wants among its neighbors&quot;
    )
    public double similarityRate;
    
    @Parameter(
       name = &quot;vacancy rate&quot;, 
       description = &quot;the rate of vacant settling places&quot;
    )
    public double vacancyRate;
    
    @Parameter(
       name = &quot;perception distance&quot;, 
       description = &quot;the perception distance of agents&quot;
    )
    public double perceptionDistance;</code></pre>
<p>The constructor defines the default values of the simulation parameters:</p>
<pre><code>    public SegregationSimulationParameters() {
        super();
        this.similarityRate = 3.0/8;
        this.vacancyRate = 0.05;
        this.perceptionDistance = Math.sqrt(2);
        this.initialTime = new SimulationTimeStamp( 0 );
        this.finalTime = new SimulationTimeStamp( 500 );
        this.xTorus = true;
        this.yTorus = true;
        this.gridHeight = 50;
        this.gridWidth = 50;
    }</code></pre>
<h4 id="model-specific-influence">Model-specific influence</h4>
<p>We define an influence called <code>Move</code> that is emitted by an agent who wants to move to another location. It is defined by a unique identifier, here “move”, and the state of the turtle that wants to move.</p>
<pre><code>public class Move extends RegularInfluence {

    public static final String CATEGORY = &quot;move&quot;;
    

    private final TurtlePLSInLogo target;
    
    public Move(SimulationTimeStamp timeLowerBound,
            SimulationTimeStamp timeUpperBound,
            TurtlePLSInLogo target) {
        super(CATEGORY, LogoSimulationLevelList.LOGO, timeLowerBound, timeUpperBound);
        this.target = target;
    }

    public TurtlePLSInLogo getTarget() {
        return target;
    }</code></pre>
<h4 id="decision-model">Decision model</h4>
<p>The decision model computes a happiness index based on the rate of turtles of different categories in its neighborhood. If the index is below the parameter <code>similarityRate</code>, the turtle emits a <code>Move</code> influence.</p>
<pre><code>    @Override
    public void decide(SimulationTimeStamp timeLowerBound,
            SimulationTimeStamp timeUpperBound, IGlobalState globalState,
            ILocalStateOfAgent publicLocalState,
            ILocalStateOfAgent privateLocalState, IPerceivedData perceivedData,
            InfluencesMap producedInfluences) {
        double similarityRate = 0;
        TurtlePLSInLogo castedPublicLocalState = (TurtlePLSInLogo) publicLocalState;
        TurtlePerceivedData castedPerceivedData = (TurtlePerceivedData) perceivedData;
        
        for(LocalPerceivedData&lt;TurtlePLSInLogo&gt; perceivedTurtle : castedPerceivedData.getTurtles()) {
            TurtlePLSInLogo castedPerceivedTurtle = (TurtlePLSInLogo) perceivedTurtle.getContent();
            if(castedPerceivedTurtle.getCategoryOfAgent().isA(castedPublicLocalState.getCategoryOfAgent())) {
                similarityRate++;
            }
        }
        if(castedPerceivedData.getTurtles().size() &gt; 0 ) {
            similarityRate/= castedPerceivedData.getTurtles().size();
        }

        if(similarityRate &lt; this.parameters.similarityRate) {
            producedInfluences.add(
                    new Move(
                        timeLowerBound,
                        timeUpperBound,
                        castedPublicLocalState
                    )
                );
        }</code></pre>
<h4 id="reaction-model">Reaction model</h4>
<p>The reaction model handles the <code>Move</code> influences emitted by unhappy turtles. First, it identifies vacant places and moves the turtles that have emitted a <code>Move</code> influence. Note that if there is not enough vacant places, not all turtle wishes can be fulfilled.</p>
<pre><code>    @Override
    public void makeRegularReaction(SimulationTimeStamp transitoryTimeMin,
            SimulationTimeStamp transitoryTimeMax,
            ConsistentPublicLocalDynamicState consistentState,
            Set&lt;IInfluence&gt; regularInfluencesOftransitoryStateDynamics,
            InfluencesMap remainingInfluences) {
        LogoEnvPLS environment = (LogoEnvPLS) consistentState.getPublicLocalStateOfEnvironment();
        List&lt;IInfluence&gt; specificInfluences = new ArrayList&lt;IInfluence&gt;();
        List&lt;Point2D&gt; vacantPlaces = new ArrayList&lt;Point2D&gt;();
        specificInfluences.addAll(regularInfluencesOftransitoryStateDynamics);
        Collections.shuffle(specificInfluences);
        //Identify vacant places
        LogoEnvPLS castedEnvState = (LogoEnvPLS) consistentState.getPublicLocalStateOfEnvironment();
        for(int x = 0; x &lt; castedEnvState.getWidth(); x++) {
            for(int y = 0; y &lt; castedEnvState.getHeight(); y++) {
                if(castedEnvState.getTurtlesAt(x, y).isEmpty()) {
                    vacantPlaces.add(
                        new Point2D.Double(x,y)
                    );
                }
            }
        }
        Collections.shuffle(vacantPlaces);
        //move agents
        int i = 0;
        for(IInfluence influence : specificInfluences) {
            if(influence.getCategory().equals(Move.CATEGORY)) {
                Move castedInfluence = (Move) influence;
                environment.getTurtlesInPatches()[(int) Math.floor(castedInfluence.getTarget().getLocation().getX())][(int) Math.floor(castedInfluence.getTarget().getLocation().getY())].remove(castedInfluence.getTarget());
                environment.getTurtlesInPatches()[(int) Math.floor(vacantPlaces.get(i).getX())][(int) Math.floor(vacantPlaces.get(i).getY())].add(castedInfluence.getTarget());
                
                castedInfluence.getTarget().setLocation(
                    vacantPlaces.get(i)
                );
                i++;
            }
            if(i &gt;= vacantPlaces.size()) {
                break;
            }
        }</code></pre>
<h4 id="simulation-model">Simulation model</h4>
<p>The simulation model generates the Logo level using the user-defined reaction model and a simple periodic time model.</p>
<pre><code>    @Override
    protected List&lt;ILevel&gt; generateLevels(
            ISimulationParameters simulationParameters) {
        ExtendedLevel logo = new ExtendedLevel(
                simulationParameters.getInitialTime(), 
                LogoSimulationLevelList.LOGO, 
                new PeriodicTimeModel( 
                    1, 
                    0, 
                    simulationParameters.getInitialTime()
                ),
                new SegregationReactionModel()
            );
        List&lt;ILevel&gt; levelList = new LinkedList&lt;ILevel&gt;();
        levelList.add(logo);
        return levelList;
    }</code></pre>
<p>It also generates turtles of 2 different types (a and b) randomly in the grid with respect to the vacancy rate parameter.</p>
<pre><code>    @Override
    protected AgentInitializationData generateAgents(
        ISimulationParameters parameters, 
        Map&lt;LevelIdentifier, ILevel&gt; levels
    ) {
        SegregationSimulationParameters castedParameters = (SegregationSimulationParameters) parameters;
        AgentInitializationData result = new AgentInitializationData();
        String t;
        for(int x = 0; x &lt; castedParameters.gridWidth; x++) {
            for(int y = 0; y &lt; castedParameters.gridHeight; y++) {
                if(PRNG.randomDouble() &gt;= castedParameters.vacancyRate) {
                    if(PRNG.randomBoolean()) {
                        t = &quot;a&quot;;
                    } else {
                        t = &quot;b&quot;;
                    }
                    IAgent4Engine turtle = TurtleFactory.generate(
                        new ConeBasedPerceptionModel(castedParameters.perceptionDistance, 2*Math.PI, true, false, false),
                        new SegregationAgentDecisionModel(castedParameters),
                        new AgentCategory(t, TurtleAgentCategory.CATEGORY),
                        0,
                        0,
                        0,
                        x,
                        y
                    );
                    result.getAgents().add( turtle );
                }
            }
        }
        
        return result;
    }</code></pre>
<h4 id="html-gui"><a name="segregationgui"></a> HTML GUI</h4>
<p>The HTML GUI specifies how turtles are displayed in the grid.Turtles of type a are colored in blue and turtles of type b are colored in red.</p>
<pre><code>&lt;canvas id=&#39;grid_canvas&#39; class=&#39;center-block&#39; width=&#39;400&#39; height=&#39;400&#39;&gt;&lt;/canvas&gt;
&lt;script type=&#39;text/javascript&#39;&gt;
    drawCanvas = function (data) {
        var json = JSON.parse(data),
            canvas = document.getElementById(&#39;grid_canvas&#39;),
            context = canvas.getContext(&#39;2d&#39;);
        context.clearRect(0, 0, canvas.width, canvas.height);
        for (var i = 0; i &lt; json.agents.length; i++) {
            var centerX = json.agents[i].x * canvas.width;
            var centerY = json.agents[i].y * canvas.height;
            var radius = 2;
            if (json.agents[i].t == &#39;a&#39;) {
                context.fillStyle = &#39;red&#39;;
            } else {
                context.fillStyle = &#39;blue&#39;;
            }
            context.beginPath();
            context.arc(centerX, centerY, radius, 0, 2 * Math.PI, false);
            context.fill();
        }
    }
&lt;/script&gt;</code></pre>
<h4 id="main-class">Main class</h4>
<p>The main method of the Main class simply launches and configures the HTML runner with the above described GUI.</p>
<pre><code>        // Creation of the runner
        Similar2LogoWebRunner runner = new Similar2LogoWebRunner( );
        // Creation of the model
        AbstractLogoSimulationModel model = new SegregationSimulationModel( new SegregationSimulationParameters() );
        // Configuration of the runner
        runner.getConfig().setCustomHtmlBody( SegregationSimulationMain.class.getResourceAsStream(&quot;segregationgui.html&quot;) );
        runner.getConfig().setExportAgents( true );
        // Initialize the runner
        runner.initializeRunner( model );
        // Open the GUI.
        runner.showView( );</code></pre>
<h3 id="adding-a-hidden-state-to-the-turtles-and-a-pheromone-field-the-heatbugs-model"><a name="jheatbugs"></a> Adding a hidden state to the turtles and a pheromone field: The heatbugs model</h3>
<p>"Heatbugs is an abstract model of the behavior of biologically-inspired agents that attempt to maintain an optimum temperature around themselves. It demonstrates how simple rules defining the behavior of agents can produce several different kinds of emergent behavior.</p>
<p>Heatbugs has been used as a demonstration model for many agent-based modeling toolkits." from <a href="http://ccl.northwestern.edu/netlogo/models/Heatbugs">the Heatbugs page</a> of the NetLogo documentation.</p>
<p>This example illustrates how to add a hidden state to the turtles and a pheromone field to a similar2logo simulation and how it can be used by turtles.</p>
<p>The simulation is located in the package <code>fr.univ_artois.lgi2a.similar2logo.examples.heatbugs</code>.</p>
<p>The model itself is defined in the package <code>fr.univ_artois.lgi2a.similar2logo.examples.heatbugs.model</code> which contains</p>
<ul>
<li><p>the <code>HeatBugsSimulationParameters</code> class that extends <code>LogoSimulationParameters</code> and defines the parameters of the model.</p></li>
<li><p>the <code>agents</code> package that defines a heat bug turtle. It contains 4 classes:</p>
<ul>
<li><p><code>HeatBugCategory</code>, which defines the category of a heat bug turtle,</p></li>
<li><p><code>HeatBugHLS</code> that extends <code>AbstractLocalStateOfAgent</code> and represents the hidden state of a heat bug,</p></li>
<li><p><code>HeatBugDecisionModel</code> that extends <code>AbstractAgtDecisionModel</code>, which defines the decision model of a heat bug,</p></li>
<li><p><code>HeatBugFactory</code>, the factory that creates a new heat bug.</p></li>
</ul></li>
<li><p>the <code>HeatBugsSimulationModel</code> class that extends <code>AbstractLogoSimulationModel</code> and defines the simulation model of the heatbugs simulation.</p></li>
<li><p>the main class of the simulation <code>HeatBugsSimulationMain</code></p></li>
</ul>
<h4 id="model-parameters-4">Model parameters</h4>
<p>First, we define the parameters of the Heatbugs simulation in the class <code>HeatBugsSimulationParameters</code>. It contains the following parameters:</p>
<pre><code>    @Parameter(
       name = &quot;number of bugs&quot;, 
       description = &quot;the number of bugs in the simulation&quot;
    )
    public int nbOfBugs;
    
    @Parameter(
       name = &quot;evaporation rate&quot;, 
       description = &quot;the percentage of the world&#39;s heat that evaporates each cycle&quot;
    )
    public double evaporationRate;
    
    @Parameter(
       name = &quot;diffusion rate&quot;, 
       description = &quot;How much heat a patch (a spot in the world) diffuses to its neighbors&quot;
    )
    public double diffusionRate;
    
    @Parameter(
       name = &quot;min optimal temperature&quot;, 
       description = &quot;the minimum ideal temperatures for heatbugs&quot;
    )
    public double minOptimalTemperature;
    
    @Parameter(
       name = &quot;max optimal temperature&quot;, 
       description = &quot;the maximum ideal temperatures for heatbugs&quot;
    )
    public double maxOptimalTemperature;
    
    @Parameter(
       name = &quot;min output heat&quot;, 
       description = &quot;the minimum heat that heatbugs generate each cycle&quot;
    )
    public double minOutputHeat;
    
    @Parameter(
       name = &quot;max output heat&quot;, 
       description = &quot;the maximum heat that heatbugs generate each cycle&quot;
    )
    public double maxOutputHeat;
    
    @Parameter(
       name = &quot;random move probability&quot;, 
       description = &quot;the chance that a bug will make a random move even if it would prefer to stay where it is&quot;
    )
    public double randomMoveProbability;
    
    @Parameter(
       name = &quot;unhappiness&quot;, 
       description = &quot;the relative difference between real and optimal temperature that triggers moves&quot;
    )
    public double unhappiness;</code></pre>
<p>The parameters <code>evaporationRate</code> and <code>diffusionRate</code> relate to a pheromone field which is instantiated in the constructor of <code>HeatBugsSimulationParameters</code> that also defines the default values of the parameters.</p>
<pre><code>    public HeatBugsSimulationParameters() {
        super();
        this.nbOfBugs = 20;
        this.evaporationRate = 0.1;
        this.diffusionRate = 0.1;
        this.maxOptimalTemperature = 25;
        this.minOptimalTemperature = 10;
        this.maxOutputHeat = 3;
        this.minOutputHeat = 1;
        this.randomMoveProbability = 0.1;
        this.unhappiness = 0.1;
        this.finalTime = new SimulationTimeStamp( 30000 );
        this.gridWidth = 100;
        this.gridHeight = 100;
        this.xTorus = true;
        this.yTorus = true;
        this.pheromones.add(
            new Pheromone(&quot;heat&quot;, this.diffusionRate, this.evaporationRate)
        );
    }</code></pre>
<h4 id="heat-bug-model">Heat bug model</h4>
<p>The model of a heat bug turtle is defined by several classes</p>
<h5 id="category-of-a-heat-bug">Category of a heat bug</h5>
<p>It defines the category, i.e., type of a heat bug turtle.</p>
<pre><code>public class HeatBugCategory {
    
    public static final AgentCategory CATEGORY = new AgentCategory(&quot;heat bug&quot;, TurtleAgentCategory.CATEGORY);
    
    protected HeatBugCategory() {}  
}</code></pre>
<h5 id="hidden-state-of-a-heat-bug">Hidden state of a heat bug</h5>
<p>The hidden state describes the state of the heat bug which is not visible by other heat bugs.</p>
<pre><code>public class HeatBugHLS extends AbstractLocalStateOfAgent {

    private final double optimalTemperature;
    
    private final double outputHeat;
    
    private final double unhappiness;
    
    private final double randomMoveProbability;
    
    public HeatBugHLS(
        IAgent4Engine owner,
        double optimalTemperature,
        double outputHeat,
        double unhappiness,
        double randomMoveProbability
    ) {
        super(
            LogoSimulationLevelList.LOGO,
            owner
        );
        this.optimalTemperature = optimalTemperature;
        this.outputHeat = outputHeat;
        this.unhappiness = unhappiness;
        this.randomMoveProbability = randomMoveProbability;
    }
    
    //Getter and setters
}</code></pre>
<h5 id="decision-model-1">Decision model</h5>
<p>The decision model of a heat bug defines how it moves according to the heat (defined as a pheromone field) it feels and how it raises the heat around it.</p>
<pre><code>    @Override
    public void decide(SimulationTimeStamp timeLowerBound,
            SimulationTimeStamp timeUpperBound, IGlobalState globalState,
            ILocalStateOfAgent publicLocalState,
            ILocalStateOfAgent privateLocalState, IPerceivedData perceivedData,
            InfluencesMap producedInfluences) {
        TurtlePLSInLogo castedPLS = (TurtlePLSInLogo) publicLocalState;
        HeatBugHLS castedHLS = (HeatBugHLS) privateLocalState;
        
        TurtlePerceivedData castedPerceivedData = (TurtlePerceivedData) perceivedData;
        
        double bestValue;
        
        double bestDirection = castedPLS.getDirection();
        
        double diff = 0;
        
        for(LocalPerceivedData&lt;Double&gt; pheromone : castedPerceivedData.getPheromones().get(&quot;heat&quot;)) {
            if(MathUtil.areEqual(pheromone.getDistanceTo(), 0)) {
                diff = (pheromone.getContent() - castedHLS.getOptimalTemperature())/castedHLS.getOptimalTemperature();
                break;
            }
        }
        
        if(diff &gt; castedHLS.getUnhappiness()) {
            //If the current patch is too hot
            bestValue = Double.MAX_VALUE;
            for(LocalPerceivedData&lt;Double&gt; pheromone : castedPerceivedData.getPheromones().get(&quot;heat&quot;)) {
                if(pheromone.getContent() &lt; bestValue) {
                    bestValue = pheromone.getContent();
                    bestDirection = pheromone.getDirectionTo();
                }
            }
            producedInfluences.add(
                new ChangeDirection(
                    timeLowerBound,
                    timeUpperBound,
                    bestDirection - castedPLS.getDirection(),
                    castedPLS
                )
            );
            if(MathUtil.areEqual(castedPLS.getSpeed(), 0)) {
                producedInfluences.add(
                    new ChangeSpeed(
                        timeLowerBound,
                        timeUpperBound,
                        1,
                        castedPLS
                    )
                );
            }
        } else if(diff &lt; -castedHLS.getUnhappiness()) {
            //If the current patch is too cool
            bestValue = -Double.MAX_VALUE;
            for(LocalPerceivedData&lt;Double&gt; pheromone : castedPerceivedData.getPheromones().get(&quot;heat&quot;)) {
                if(pheromone.getContent() &gt; bestValue) {
                    bestValue = pheromone.getContent();
                    bestDirection = pheromone.getDirectionTo();
                }
            }
            producedInfluences.add(
                new ChangeDirection(
                    timeLowerBound,
                    timeUpperBound,
                    bestDirection - castedPLS.getDirection(),
                    castedPLS
                )
            );
            if(MathUtil.areEqual(castedPLS.getSpeed(), 0)) {
                producedInfluences.add(
                    new ChangeSpeed(
                        timeLowerBound,
                        timeUpperBound,
                        1,
                        castedPLS
                    )
                );
            }
        } else {
            // If the turtle is on the best patch
            if(castedHLS.getRandomMoveProbability() &gt; PRNG.randomDouble()) {
                producedInfluences.add(
                    new ChangeDirection(
                        timeLowerBound,
                        timeUpperBound,
                        PRNG.randomDouble()*2*Math.PI,
                        castedPLS
                    )
                );
                if(MathUtil.areEqual(castedPLS.getSpeed(), 0)) {
                    producedInfluences.add(
                        new ChangeSpeed(
                            timeLowerBound,
                            timeUpperBound,
                            1,
                            castedPLS
                        )
                    );
                }
            } else if(!MathUtil.areEqual(castedPLS.getSpeed(), 0)) {
                producedInfluences.add(
                    new Stop(
                        timeLowerBound,
                        timeUpperBound,
                        castedPLS
                    )
                );
            }
        }
        producedInfluences.add(
            new EmitPheromone(
                timeLowerBound,
                timeUpperBound,
                castedPLS.getLocation(),
                HeatBugsSimulationParameters.HEAT_FIELD_ID,
                castedHLS.getOutputHeat()
            )
        );
    }</code></pre>
<h5 id="heat-bug-factory">Heat bug factory</h5>
<p>Since heat bug turtles have a hidden state, we cannot use the default turtle factory. We have to define how a heat bug is generated.</p>
<pre><code>public class HeatBugFactory {
    
    protected HeatBugFactory() {}
     
    public static ExtendedAgent generate(
            AbstractAgtPerceptionModel turtlePerceptionModel,
            AbstractAgtDecisionModel turtleDecisionModel,
            AgentCategory category,
            double initialDirection,
            double initialSpeed,
            double initialAcceleration,
            double initialX,
            double initialY,
            double optimalTemperature,
            double outputHeat,
            double unhappiness,
            double randomMoveProbability
    ){
        if( ! category.isA(HeatBugCategory.CATEGORY) ) {
            throw new IllegalArgumentException( &quot;Only turtle agents are accepted.&quot; );
        }
        ExtendedAgent turtle = new ExtendedAgent( category );
        // Defines the revision model of the global state.
        turtle.specifyGlobalStateRevisionModel(
            new IdentityAgtGlobalStateRevisionModel( )
        );
        
        //Defines the behavior of the turtle.
        turtle.specifyBehaviorForLevel(
            LogoSimulationLevelList.LOGO, 
            turtlePerceptionModel, 
            turtleDecisionModel
        );
        
        // Define the initial global state of the turtle.
        turtle.initializeGlobalState( new EmptyGlobalState( ) );
        turtle.includeNewLevel(
            LogoSimulationLevelList.LOGO,
            new TurtlePLSInLogo( 
                turtle, 
                initialX,
                initialY, 
                initialSpeed,
                initialAcceleration,
                initialDirection
            ),
            new HeatBugHLS(
                turtle,
                optimalTemperature,
                outputHeat,
                unhappiness,
                randomMoveProbability
            )
        );
        
        return turtle;
    }</code></pre>
<h4 id="simulation-model-1">Simulation model</h4>
<p>The simulation model generates heat bugs randomly in the environment.</p>
<pre><code>    @Override
    protected AgentInitializationData generateAgents(
            ISimulationParameters parameters, Map&lt;LevelIdentifier, ILevel&gt; levels) {
        HeatBugsSimulationParameters castedParameters = (HeatBugsSimulationParameters) parameters;
        AgentInitializationData result = new AgentInitializationData();
        for(int i = 0; i &lt; castedParameters.nbOfBugs; i++) {
            IAgent4Engine turtle = HeatBugFactory.generate(
                new ConeBasedPerceptionModel(1, 2*Math.PI, false, false, true),
                new HeatBugDecisionModel(),
                HeatBugCategory.CATEGORY,
                PRNG.randomDouble()*2*Math.PI,
                0,
                0,
                Math.floor(PRNG.randomDouble()*castedParameters.gridWidth) + 0.5,
                Math.floor(PRNG.randomDouble()*castedParameters.gridHeight) + 0.5,
                castedParameters.minOptimalTemperature +
                PRNG.randomDouble()*(
                        castedParameters.maxOptimalTemperature  - castedParameters.minOptimalTemperature
                ),
                castedParameters.minOutputHeat +
                PRNG.randomDouble()*(
                        castedParameters.maxOutputHeat  - castedParameters.minOutputHeat
                ),
                castedParameters.unhappiness,
                castedParameters.randomMoveProbability
                
            );
            result.getAgents().add( turtle );
        }
        
        return result;
    }</code></pre>
<h4 id="main-class-1">Main class</h4>
<p>As usual, the main method of the Main class launches and configure the HTML runner. In this case, we want to display the turtles and the pheromone field.</p>
<pre><code>        // Creation of the runner
        Similar2LogoWebRunner runner = new Similar2LogoWebRunner( );
        // Creation of the model
        AbstractLogoSimulationModel model = new HeatBugsSimulationModel( new HeatBugsSimulationParameters() );
        // Configuration of the runner
        runner.getConfig().setExportAgents( true );
        runner.getConfig().setExportPheromones( true );
        // Initialize the runner
        runner.initializeRunner( model );
        // Open the GUI.
        runner.showView( );</code></pre>
<h2 id="groovy-examples"><a name="gexamples"></a> Groovy Examples</h2>
<p>In the following we comment the examples written in Groovy distributed with Similar2Logo. Each example introduces a specific feature.</p>
<ul>
<li><p><a href="#gpassive">A first example with a passive turtle</a></p></li>
<li><p><a href="#gboids">Adding a user-defined decision model to the turtles: The boids model</a></p></li>
<li><p><a href="#gturmite">Dealing with marks: the turmite model</a></p></li>
<li><p><a href="#gsegregation">Adding user-defined influence, reaction model and GUI: The segregation model</a></p></li>
</ul>
<h3 id="a-first-example-with-a-passive-turtle-1"><a name="gpassive"></a> A first example with a passive turtle</h3>
<p>First we consider a simple example with a single passive agent. The example source code is located in the package <code>fr.univ_artois.lgi2a.similar2logo.examples.passive</code>. It contains 1 groovy script.</p>
<p>Foremost, we define the parameters of the model by creating an object that inherits from <code>LogoSimulationParameters</code>, that contains the generic parameters of a Logo-like simulation (environment size, topology, etc.).</p>
<pre><code>def simulationParameters = new LogoSimulationParameters() {

    @Parameter(
        name = &quot;initial x&quot;,
        description = &quot;the initial position of the turtle on the x axis&quot;
     )
     public double initialX = 0
     
     @Parameter(
        name = &quot;initial y&quot;,
        description = &quot;the initial position of the turtle on the y axis&quot;
     )
     public double initialY = 0
     
     @Parameter(
        name = &quot;initial speed&quot;,
        description = &quot;the initial speed of the turtle&quot;
     )
     public double initialSpeed = 0.1
     
     @Parameter(
        name = &quot;initial acceleration&quot;,
        description = &quot;the initial acceleration of the turtle&quot;
     )
     public double initialAcceleration = 0
     
     @Parameter(
        name = &quot;initial direction&quot;,
        description = &quot;the initial direction of the turtle&quot;
     )
     public double initialDirection = LogoEnvPLS.NORTH

}</code></pre>
<p>Note that each parameter is prefixed with the <code>@Parameter</code> annotation. This annotation is mandatory to be able to change the value of the parameters in the GUI.</p>
<p>Then, we define the simulation model i.e, the initial state of the simulation from the <code>AbstractLogoSimulationModel</code> class. We must implement the <code>generateAgents</code> method to describe the initial state of our passive turtle.</p>
<pre><code>def simulationModel = new AbstractLogoSimulationModel(simulationParameters) {
    protected AgentInitializationData generateAgents(
        ISimulationParameters p,
        Map&lt;LevelIdentifier, ILevel&gt; levels
    ) {
        AgentInitializationData result = new AgentInitializationData()
        IAgent4Engine turtle = TurtleFactory.generate(
            new EmptyPerceptionModel(),
            new PassiveTurtleDecisionModel(),
            new AgentCategory(&quot;passive&quot;, TurtleAgentCategory.CATEGORY),
            p.initialDirection,
            p.initialSpeed,
            p.initialAcceleration,
            p.initialX,
            p.initialY
        )
        result.agents.add turtle
        return result
    }
}</code></pre>
<p>Then we launch and configure the HTML runner. Here, only the turtles are displayed. Finally, the probe <code>RealTimeMatcherProbe</code> is added to the server to slow down the simulation so that its execution speed matches a specific factor of N steps per second.</p>
<pre><code>def runner = new Similar2LogoWebRunner( )
runner.config.exportAgents = true
runner.initializeRunner simulationModel
runner.showView( )
runner.addProbe &quot;Real time matcher&quot;, new RealTimeMatcherProbe(20)</code></pre>
<h3 id="adding-a-user-defined-decision-module-to-the-turtles-the-boids-model"><a name="gboids"></a> Adding a user-defined decision module to the turtles: The boids model</h3>
<p>The <a href="https://en.wikipedia.org/wiki/Boids">boids</a> (bird-oid) model has been invented by <a href="https://en.wikipedia.org/wiki/Craig_Reynolds_(computer_graphics)">Craig Reynolds</a> in 1986 to simulate the flocking behavior of birds. It is based on 3 principles:</p>
<ul>
<li><p>separation: boids tend to avoid other boids that are too close,</p></li>
<li><p>alignment: boids tend to align their velocity to boids that are not too close and not too far away,</p></li>
<li><p>cohesion: bois tend to move towards boids that are too far away.</p></li>
</ul>
<p>While these rules are essentially heuristic, they can be implemented defining three areas (repulsion, orientation, attraction) for each principle.</p>
<ul>
<li><p>Boids change their orientation to get away from other boids in the repulsion area,</p></li>
<li><p>Boids change their orientation and speed to match those of other boids in the orientation area,</p></li>
<li><p>Boids change their orientation to get to other boids in the attraction area.</p></li>
</ul>
<p>An implementation of such model is located in the package <code>fr.univ_artois.lgi2a.similar2logo.examples.boids</code> which contains 1 groovy script called <code>GroovyBoidsSimulation</code>.</p>
<h4 id="model-parameters-5">Model parameters</h4>
<p>The model parameters and their default values are defined as in the previous example.</p>
<pre><code>def parameters = new LogoSimulationParameters() {

     @Parameter(name = &quot;repulsion distance&quot;, description = &quot;the repulsion distance&quot;)
     public double repulsionDistance = 6
     
     @Parameter(name = &quot;attraction distance&quot;, description = &quot;the attraction distance&quot;)
     public double attractionDistance = 14
     
     @Parameter(name = &quot;orientation distance&quot;, description = &quot;the orientation distance&quot;)
     public double orientationDistance = 10
     
     @Parameter(name = &quot;maximal initial speed&quot;, description = &quot;the maximal initial speed&quot;)
     public double maxInitialSpeed = 2
     
     @Parameter(name = &quot;minimal initial speed&quot;, description = &quot;the minimal initial speed&quot;)
     public double minInitialSpeed = 1
     
     @Parameter(name = &quot;perception angle&quot;, description = &quot;the perception angle in rad&quot;)
     public double perceptionAngle = PI
     
     @Parameter(name = &quot;number of agents&quot;, description = &quot;the number of boids in the simulation&quot;)
     public int nbOfAgents = 200
    
     @Parameter(name = &quot;max angular speed&quot;, description = &quot;the maximal angular speed in rad/step&quot;)
     public double maxAngle = PI/8
}</code></pre>
<h4 id="decision-model-2">Decision model</h4>
<p>The decision model consists in changing the direction and speed of the boids according to the previously described rules. To define a decision model, the modeler must define an object that extends <code>AbstractAgtDecisionModel</code> and implement the <code>decide</code> method.</p>
<pre><code>def decisionModel = new AbstractAgtDecisionModel(LogoSimulationLevelList.LOGO) {                            
    void decide(                                                                                        
        SimulationTimeStamp s,                                                                          
        SimulationTimeStamp ns,                                                                     
        IGlobalState gs,    
        ILocalStateOfAgent pls,
        ILocalStateOfAgent prls,
        IPerceivedData pd,
        InfluencesMap i 
    ) { 
        if(!pd.turtles.empty) { 
            def meanAngle = new MeanAngle(), sc=0, n = 0                                                                        
            pd.turtles.each{ boid -&gt;
                switch(boid.distanceTo) {
                    case {it &lt;= parameters.repulsionDistance}:                                          //the repulsion area
                        meanAngle.add(pls.direction - boid.directionTo, parameters.repulsionWeight)
                        break
                    case {it &gt; parameters.repulsionDistance &amp;&amp; it &lt;= parameters.orientationDistance}:       //the orientation area
                        meanAngle.add(boid.content.direction - pls.direction,parameters.orientationWeight)
                        sc+=boid.content.speed - pls.speed
                        n++
                        break
                    case {it &gt; parameters.orientationDistance &amp;&amp; it &lt;= parameters.attractionDistance}:      //the attraction area
                        meanAngle.add(boid.directionTo- pls.direction, parameters.attractionWeight)
                        break
                }
            }
            def oc = meanAngle.value()
            if (!MathUtil.areEqual(oc, 0)) {
                if(abs(oc) &gt; parameters.maxAngle) oc = signum(oc)*parameters.maxAngle
                i.add new ChangeDirection(s, ns, oc, pls)
            }
            if (n &gt; 0) i.add new ChangeSpeed(s, ns, sc/n, pls)
        }
    }
}</code></pre>
<h4 id="the-simulation-model-4">The simulation model</h4>
<p>In the simulation model defined in our example, boids are initially located randomly in the environment with a random orientation and speed.</p>
<pre><code>def simulationModel = new AbstractLogoSimulationModel(parameters) {
    protected AgentInitializationData generateAgents(
        ISimulationParameters p,
        Map&lt;LevelIdentifier, ILevel&gt; l
    ) {
        def result = new AgentInitializationData()
        p.nbOfAgents.times {
            result.agents.add TurtleFactory.generate(
                new ConeBasedPerceptionModel(p.attractionDistance,p.perceptionAngle,true,false,false),
                decisionModel,
                new AgentCategory(&quot;b&quot;, TurtleAgentCategory.CATEGORY),
                PRNG.randomAngle(),
                p.minInitialSpeed + PRNG.randomDouble()*(p.maxInitialSpeed-p.minInitialSpeed),
                0,
                p.gridWidth/2,
                p.gridHeight/2
            )
        }
        return result
    }
}</code></pre>
<h4 id="launch-the-html-runner">Launch the HTML runner</h4>
<p>Finally, we launch and configure the HTML runner as in the previous example.</p>
<pre><code>def runner = new Similar2LogoWebRunner( )
runner.config.exportAgents = true
runner.initializeRunner simulationModel
runner.showView( )</code></pre>
<h3 id="dealing-with-marks-the-turmite-model-1"><a name="gturmite"></a> Dealing with marks: the turmite model</h3>
<p>The <a href="https://en.wikipedia.org/wiki/Langton&#39;s_ant">turmite model</a>, developed by <a href="https://en.wikipedia.org/wiki/Christopher_Langton">Christopher Langton</a> in 1986, is a very simple mono-agent model that exhibits an emergent behavior. It is based on 2 rules:</p>
<ul>
<li><p>If the turmite is on a patch that does not contain a mark, it turns right, drops a mark, and moves forward,</p></li>
<li><p>If the turmite is on a patch that contains a mark, it turns left, removes the mark, and moves forward.</p></li>
</ul>
<p>The example source code is located in the package <code>fr.univ_artois.lgi2a.similar2logo.examples.turmite</code>. It contains 1 Groovy script called <code>GroovyTurmiteSimulation</code>.</p>
<h4 id="model-parameters-6">Model parameters</h4>
<p>First we define the simulation parameters. Here we only need to specify the final step of the simulation:</p>
<pre><code>def parameters = new LogoSimulationParameters(                                              
    finalTime: new SimulationTimeStamp(100000)
)</code></pre>
<h4 id="decision-model-3">Decision model</h4>
<p>The decision model implements the above described rules :</p>
<pre><code>def decisionModel = new AbstractAgtDecisionModel(LogoSimulationLevelList.LOGO) {            
    void decide(
        SimulationTimeStamp s,
        SimulationTimeStamp ns,
        IGlobalState gs,
        ILocalStateOfAgent pls,
        ILocalStateOfAgent prls,
        IPerceivedData pd,
        InfluencesMap i
    ) { 
        if(pd.marks.empty) i.with {
            add new ChangeDirection(s, ns, PI/2, pls)
            add new DropMark(s, ns, new Mark((Point2D) pls.location.clone(), null))
        } else i.with {
            add new ChangeDirection(s, ns, -PI/2, pls)
            add new RemoveMark(s, ns,pd.marks.iterator().next().content)
        }
    }
}</code></pre>
<h4 id="simulation-model-2">Simulation model</h4>
<p>The simulation model generates a turmite heading north at the location 10.5,10.5 with a speed of 1 and an acceleration of 0:</p>
<pre><code>def simulationModel = new AbstractLogoSimulationModel(parameters) {
    protected AgentInitializationData generateAgents(
        ISimulationParameters simulationParameters,
        Map&lt;LevelIdentifier, ILevel&gt; levels
    ) {
        def turmite = TurtleFactory.generate(                                   
            new ConeBasedPerceptionModel(0, 2*Math.PI, false, true, false),
            decisionModel,
            new AgentCategory(&quot;turmite&quot;, TurtleAgentCategory.CATEGORY),
            LogoEnvPLS.NORTH,
            1,
            0,
            10.5, 10.5
        ),
            result = new AgentInitializationData()
        result.agents.add turmite
        return result
    }
}</code></pre>
<h4 id="launch-the-html-runner-1">Launch the HTML runner</h4>
<pre><code>def runner = new Similar2LogoWebRunner( )
runner.config.exportAgents = true
runner.config.exportMarks = true
runner.initializeRunner simulationModel
runner.addProbe &quot;Real time matcher&quot;, new RealTimeMatcherProbe(20)
runner.showView( )  </code></pre>
<p>The main difference with the previous example is that in this case we want to observe turtles and marks.</p>
<h3 id="adding-user-defined-influence-reaction-model-and-gui-the-segregation-model-1"><a name="gsegregation"></a> Adding user-defined influence, reaction model and GUI: The segregation model</h3>
<p>The segregation model has been proposed by <a href="https://en.wikipedia.org/wiki/Thomas_Schelling">Thomas Schelling</a> in 1971 in his famous paper <a href="https://www.stat.berkeley.edu/~aldous/157/Papers/Schelling_Seg_Models.pdf">Dynamic Models of Segregation</a>. The goal of this model is to show that segregation can occur even if it is not wanted by the agents.</p>
<p>In our implementation of this model, turtles are located in the grid and at each step, compute an happiness index based on the similarity of other agents in their neighborhood. If this index is below a value, called here similarity rate, the turtle wants to move to an other location.</p>
<h4 id="model-parameters-7">Model parameters</h4>
<p>We define the following parameters and their default values.</p>
<pre><code>def parameters = new LogoSimulationParameters() {

    @Parameter(
        name = &quot;similarity rate&quot;,
        description = &quot;the rate of same-color turtles that each turtle wants among its neighbors&quot;
     )
     public double similarityRate = 3.0/8
     
     @Parameter(name = &quot;vacancy rate&quot;, description = &quot;the rate of vacant settling places&quot;)
     public double vacancyRate = 0.05
     
     @Parameter(name = &quot;perception distance&quot;, description = &quot;the perception distance of agents&quot;)
     public double perceptionDistance = sqrt(2)
}</code></pre>
<h4 id="model-specific-influence-1">Model-specific influence</h4>
<p>We define an influence called <code>Move</code> that is emitted by an agent who wants to move to another location. It is defined by a unique identifier, here “move”, and the state of the turtle that wants to move.</p>
<pre><code>class Move extends RegularInfluence {                                                                   
    def target                                                                                          
    static final def CATEGORY = &quot;move&quot;
    
    Move(SimulationTimeStamp s, SimulationTimeStamp ns, TurtlePLSInLogo target) {
        super(CATEGORY, LOGO, s, ns)
        this.target = target                                                                        
    }
}</code></pre>
<h4 id="decision-model-4">Decision model</h4>
<p>The decision model computes a happiness index based on the rate of turtles of different categories in its neighborhood. If the index is below the parameter <code>similarityRate</code>, the turtle emits a <code>Move</code> influence.</p>
<pre><code>def decisionModel = new AbstractAgtDecisionModel(LOGO) {                                                
    void decide(
        SimulationTimeStamp s,
        SimulationTimeStamp ns,
        IGlobalState gs,
        ILocalStateOfAgent pls,
        ILocalStateOfAgent prls,
        IPerceivedData pd,
        InfluencesMap i 
    ) {
        def sr = 0
        pd.turtles.each{ agent -&gt; if(agent.content.categoryOfAgent.isA(pls.categoryOfAgent)) sr++ }
        if(!pd.turtles.empty) sr/= pd.turtles.size()
        if(sr &lt; parameters.similarityRate) i.add new Move(s, ns, pls)
    }
}</code></pre>
<h4 id="reaction-model-1">Reaction model</h4>
<p>The reaction model handles the <code>Move</code> influences emitted by unhappy turtles. First, it identifies vacant places and moves the turtles that have emitted a <code>Move</code> influence. Note that if there is not enough vacant places, not all turtle wishes can be fulfilled.</p>
<pre><code>def reactionModel = new LogoDefaultReactionModel() {
    //redefine the reaction function for regular influences
    public void makeRegularReaction(
        SimulationTimeStamp s,
        SimulationTimeStamp ns,
        ConsistentPublicLocalDynamicState cs,
        Set&lt;IInfluence&gt; influences, 
        InfluencesMap remainingInfluences
    ) {
        def e = cs.publicLocalStateOfEnvironment,
            li = [], //the list of influences
            vacant = [] //the list of vacant housings   
        li.addAll influences //create the list of influences
        PRNG.shuffle li //shuffle the list of influences
        for(x in 0..&lt;e.width) for(y in 0..&lt;e.height)
            if(e.getTurtlesAt(x, y).empty) vacant.add new Point2D.Double(x,y)
        PRNG.shuffle vacant
        def n = 0 
        li.any{ i -&gt;
            if(i.category == Move.CATEGORY) {
                e.turtlesInPatches[(int) i.target.location.x][(int) i.target.location.y].remove i.target
                e.turtlesInPatches[(int) vacant[n].x][(int) vacant[n].y].add i.target
                i.target.setLocation(vacant[n])
                if(++n &gt;= vacant.size()) return true
            }
        }
    }
}</code></pre>
<h4 id="simulation-model-3">Simulation model</h4>
<p>The simulation model generates the Logo level using the user-defined reaction model and a simple periodic time model. It also generates turtles of 2 different types (a and b) randomly in the grid with respect to the vacancy rate parameter.</p>
<pre><code>def simulationModel = new AbstractLogoSimulationModel(parameters) {
    
    List&lt;ILevel&gt; generateLevels(ISimulationParameters p) {
        def logo = new ExtendedLevel(
            p.initialTime,
            LOGO,
            new PeriodicTimeModel(1,0, p.initialTime),
            reactionModel
        )
        def levelList = []
        levelList.add logo
        return levelList
    }

    AgentInitializationData generateAgents(ISimulationParameters p, Map&lt;LevelIdentifier, ILevel&gt; l) {
        def result = new AgentInitializationData()
        for(x in 0..&lt;p.gridWidth) for(y in 0..&lt;p.gridHeight)
            if(PRNG.randomDouble() &gt;= p.vacancyRate) result.agents.add TurtleFactory.generate(
                new ConeBasedPerceptionModel(p.perceptionDistance, 2*PI, true, false, false),
                decisionModel,
                new AgentCategory(PRNG.randomBoolean() ? &quot;a&quot; :&quot;b&quot;, TurtleAgentCategory.CATEGORY),
                0, 0, 0, x,y
            )
        return result
    }
}</code></pre>
<h4 id="html-gui-1">HTML GUI</h4>
<p>The GUI is defined in a variable called <code>segregationgui</code>.</p>
<pre><code>def segregationgui = &#39;&#39;&#39;
    &lt;canvas id=&#39;grid_canvas&#39; class=&#39;center-block&#39; width=&#39;400&#39; height=&#39;400&#39;&gt;&lt;/canvas&gt;
    &lt;script type=&#39;text/javascript&#39;&gt;
        drawCanvas = function (data) {
            var json = JSON.parse(data),
                canvas = document.getElementById(&#39;grid_canvas&#39;),
                context = canvas.getContext(&#39;2d&#39;);
            context.clearRect(0, 0, canvas.width, canvas.height);
            for (var i = 0; i &lt; json.agents.length; i++) {
                var centerX = json.agents[i].x * canvas.width;
                var centerY = json.agents[i].y * canvas.height;
                var radius = 2;
                if (json.agents[i].t == &#39;a&#39;) {
                    context.fillStyle = &#39;red&#39;;
                } else {
                    context.fillStyle = &#39;blue&#39;;
                }
                context.beginPath();
                context.arc(centerX, centerY, radius, 0, 2 * Math.PI, false);
                context.fill();
            }
        }
    &lt;/script&gt;&#39;&#39;&#39;</code></pre>
<h4 id="launch-the-html-runner-2">Launch the HTML runner</h4>
<p>Finally, we launch the web server with the above described GUI.</p>
<pre><code>def runner = new Similar2LogoWebRunner( )
runner.config.exportAgents = true
runner.config.setCustomHtmlBodyFromString segregationgui
runner.initializeRunner simulationModel
runner.showView( )  </code></pre>
<h2 id="ruby-examples"><a name="rexamples"></a> Ruby Examples</h2>
<p>In the following we comment the examples written in Ruby distributed with Similar2Logo. Each example introduces a specific feature.</p>
<ul>
<li><p><a href="#rpassive">A first example with a passive turtle</a></p></li>
<li><p><a href="#rboids">Adding a user-defined decision model to the turtles: The boids model</a></p></li>
<li><p><a href="#rturmite">Dealing with marks: the turmite model</a></p></li>
<li><p><a href="#rsegregation">Adding user-defined influence, reaction model and GUI: The segregation model</a></p></li>
</ul>
<p>Note that to load needed Java libraries, you must specify where they are located in your Ruby scripts or classes according to the location of your Similar2Logo installation. E.g.,</p>
<pre><code>require &#39;java&#39;
Dir[&quot;/Users/morvan/Logiciels/similar2logo/similar2logo-distribution/target/similar2logo-distribution-0.9-SNAPSHOT-bin/lib/*.jar&quot;].each { |jar| require jar }</code></pre>
<p>To import needed Java classes, you must use the <code>java_import</code> statement. E.g., to import <code>AbstractLogoSimulationModel</code>, add the following line to your script or class</p>
<pre><code>java_import &#39;fr.univ_artois.lgi2a.similar2logo.kernel.initializations.AbstractLogoSimulationModel&#39;</code></pre>
<h3 id="a-first-example-with-a-passive-turtle-2"><a name="rpassive"></a> A first example with a passive turtle</h3>
<p>First we consider a simple example with a single passive agent. The example source code is located in the package <code>fr.univ_artois.lgi2a.similar2logo.examples.passive</code>. It contains 1 Ruby script.</p>
<p>Foremost, we define the parameter class of the model by creating an object that inherits from <code>LogoSimulationParameters</code>, that contains the generic parameters of a Logo-like simulation (environment size, topology, etc.).</p>
<pre><code>class PassiveSimulationParameters &lt; LogoSimulationParameters
  
  def initialX; 10 end
  
  def initialY; 10 end
  
  def initialSpeed; 1 end
  
  def initialAcceleration; 0 end
  
  def initialDirection; LogoEnvPLS::NORTH end
  
end</code></pre>
<p>Contrary to Java and Groovy simulations, it is not (yet) possible to change the value of the parameters in the GUI.</p>
<p>Then, we define the simulation model model, i.e, the initial state of the simulation from the <code>AbstractLogoSimulationModel</code> class. We must implement the <code>generateAgents</code> method to describe the initial state of our passive turtle.</p>
<pre><code>class PassiveSimulationModel &lt; AbstractLogoSimulationModel
  def generateAgents(p, levels)
    result =  AgentInitializationData.new
    turtle = TurtleFactory::generate(
      EmptyPerceptionModel.new,
      PassiveTurtleDecisionModel.new,
      AgentCategory.new(&quot;passive&quot;, TurtleAgentCategory::CATEGORY),
      p.initialDirection,
      p.initialSpeed,
      p.initialAcceleration,
      p.initialX,
      p.initialY
    )
    result.agents.add(turtle)
    return result
  end
end</code></pre>
<p>We can now instanciate the parameters and the simulation model.</p>
<pre><code>simulationParameters = PassiveSimulationParameters.new
simulationModel = PassiveSimulationModel.new(simulationParameters)</code></pre>
<p>Then we launch and configure the HTML runner. Here, only the turtles are displayed. Finally, the probe <code>RealTimeMatcherProbe</code> is added to the server to slow down the simulation so that its execution speed matches a specific factor of N steps per second.</p>
<pre><code>runner = Similar2LogoWebRunner.new
runner.config.setExportAgents(true)
runner.initializeRunner(simulationModel)
runner.showView
runner.addProbe(&quot;Real time matcher&quot;, RealTimeMatcherProbe.new(20))</code></pre>
<h3 id="adding-a-user-defined-decision-module-to-the-turtles-the-boids-model-1"><a name="rboids"></a> Adding a user-defined decision module to the turtles: The boids model</h3>
<p>The <a href="https://en.wikipedia.org/wiki/Boids">boids</a> (bird-oid) model has been invented by <a href="https://en.wikipedia.org/wiki/Craig_Reynolds_(computer_graphics)">Craig Reynolds</a> in 1986 to simulate the flocking behavior of birds. It is based on 3 principles:</p>
<ul>
<li><p>separation: boids tend to avoid other boids that are too close,</p></li>
<li><p>alignment: boids tend to align their velocity to boids that are not too close and not too far away,</p></li>
<li><p>cohesion: bois tend to move towards boids that are too far away.</p></li>
</ul>
<p>While these rules are essentially heuristic, they can be implemented defining three areas (repulsion, orientation, attraction) for each principle.</p>
<ul>
<li><p>Boids change their orientation to get away from other boids in the repulsion area,</p></li>
<li><p>Boids change their orientation and speed to match those of other boids in the orientation area,</p></li>
<li><p>Boids change their orientation to get to other boids in the attraction area.</p></li>
</ul>
<p>An implementation of such model is located in the package <code>fr.univ_artois.lgi2a.similar2logo.examples.boids</code> which contains 1 Ruby script called <code>RubyBoidsSimulation</code>.</p>
<h4 id="model-parameters-8">Model parameters</h4>
<p>The model parameters and their default values are defined as in the previous example.</p>
<pre><code>class BoidsSimulationParameters &lt; LogoSimulationParameters
  
  attr_accessor :repulsionDistance, :attractionDistance, :orientationDistance, :repulsionWeight, :orientationWeight, :attractionWeight, :maxInitialSpeed, :minInitialSpeed, :perceptionAngle, :nbOfAgents, :maxAngle
  
  def initialize
    
    @repulsionDistance = 6
  
    @attractionDistance = 14
  
    @orientationDistance  = 10
    
    @repulsionWeight = 1
    
    @orientationWeight = 1
    
    @attractionWeight = 1
  
    @maxInitialSpeed = 2
  
    @minInitialSpeed = 1
  
    @perceptionAngle = Math::PI
  
    @nbOfAgents = 200
 
    @maxAngle = Math::PI/8
  end
  
end</code></pre>
<h4 id="decision-model-5">Decision model</h4>
<p>The decision model consists in changing the direction and speed of the boids according to the previously described rules. To define a decision model, the modeler must define an object that extends <code>AbstractAgtDecisionModel</code> and implement the <code>decide</code> method.</p>
<pre><code>class BoidDecisionModel &lt; AbstractAgtDecisionModel
  
  def initialize(parameters)
    super(LogoSimulationLevelList::LOGO)
    @parameters = parameters
  end
  
  def decide(
    timeLowerBound,
    timeUpperBound,
    globalState,
    publicLocalState,
    privateLocalState,
    perceivedData,
    producedInfluences
  )
    if !perceivedData.getTurtles.empty?
      meanAngle = MeanAngle.new
      orientationSpeed = 0
      nbOfTurtlesInOrientationArea = 0
      perceivedData.getTurtles.each do |perceivedTurtle|
        if perceivedTurtle  != publicLocalState
          if perceivedTurtle.getDistanceTo &lt;= @parameters.repulsionDistance
            meanAngle.add(publicLocalState.getDirection - perceivedTurtle.getDirectionTo, @parameters.repulsionWeight)
          elsif perceivedTurtle.getDistanceTo &lt;= @parameters.orientationDistance
            meanAngle.add(perceivedTurtle.getContent.getDirection - publicLocalState.getDirection, @parameters.orientationWeight)
            orientationSpeed+=perceivedTurtle.getContent.getSpeed - publicLocalState.getSpeed
            nbOfTurtlesInOrientationArea+=1
          elsif perceivedTurtle.getDistanceTo &lt;= @parameters.attractionDistance
            meanAngle.add(perceivedTurtle.getDirectionTo- publicLocalState.getDirection, @parameters.attractionWeight)
          end
        end
      end
      dd = meanAngle.value
      if !MathUtil::areEqual(dd, 0)
        if dd &gt; @parameters.maxAngle
          dd = @parameters.maxAngle
        elsif dd&lt;-@parameters.maxAngle
          dd = -@parameters.maxAngle
        end
        producedInfluences.add(
          ChangeDirection.new(
           timeLowerBound,
           timeUpperBound,
           dd,
           publicLocalState
         )
       )
     end
     if nbOfTurtlesInOrientationArea &gt; 0
        orientationSpeed /= nbOfTurtlesInOrientationArea
        producedInfluences.add(
          ChangeSpeed.new(
            timeLowerBound,
            timeUpperBound,
            orientationSpeed,
            publicLocalState
          )
        )
     end
    end
  end
end</code></pre>
<h4 id="the-simulation-model-5">The simulation model</h4>
<p>In the simulation model defined in our example, boids are initially located at the center of the environment with a random orientation and speed.</p>
<pre><code>class BoidsSimulationModel &lt; AbstractLogoSimulationModel
  def generateAgents(p, levels)
     result =  AgentInitializationData.new
     p.nbOfAgents.times do
      result.getAgents.add(
        TurtleFactory::generate(
         ConeBasedPerceptionModel.new(p.attractionDistance,p.perceptionAngle,true,false,false),
         BoidDecisionModel.new(p),
         AgentCategory.new(&quot;b&quot;, TurtleAgentCategory::CATEGORY),
         Math::PI-PRNG.randomDouble*2*Math::PI,
         p.minInitialSpeed + PRNG.randomDouble*(
           p.maxInitialSpeed-p.minInitialSpeed
         ),
         0,
         p.gridWidth/2,
         p.gridHeight/2
       )
      )
    end
    return result
  end
end</code></pre>
<h4 id="launch-the-html-runner-3">Launch the HTML runner</h4>
<p>Finally, we launch and configure the HTML runner as in the previous example.</p>
<pre><code>runner = Similar2LogoWebRunner.new
runner.config.setExportAgents(true)
runner.initializeRunner(BoidsSimulationModel.new(BoidsSimulationParameters.new))
runner.showView</code></pre>
<h3 id="dealing-with-marks-the-turmite-model-2"><a name="rturmite"></a> Dealing with marks: the turmite model</h3>
<p>The <a href="https://en.wikipedia.org/wiki/Langton&#39;s_ant">turmite model</a>, developed by <a href="https://en.wikipedia.org/wiki/Christopher_Langton">Christopher Langton</a> in 1986, is a very simple mono-agent model that exhibits an emergent behavior. It is based on 2 rules:</p>
<ul>
<li><p>If the turmite is on a patch that does not contain a mark, it turns right, drops a mark, and moves forward,</p></li>
<li><p>If the turmite is on a patch that contains a mark, it turns left, removes the mark, and moves forward.</p></li>
</ul>
<p>The example source code is located in the package <code>fr.univ_artois.lgi2a.similar2logo.examples.turmite</code>. It contains 1 Ruby script called <code>RubyTurmiteSimulation</code>.</p>
<h4 id="the-decision-model-1">The decision model</h4>
<p>The decision model implements the above described rules :</p>
<pre><code>class TurmiteDecisionModel &lt; AbstractAgtDecisionModel
  
  def initialize
    super(LogoSimulationLevelList::LOGO)
  end
  
  def decide(
      timeLowerBound,
      timeUpperBound,
      globalState,
      publicLocalState,
      privateLocalState,
      perceivedData,
      producedInfluences
    )
    if perceivedData.getMarks.empty?
      producedInfluences.add(
        ChangeDirection.new(
          timeLowerBound,
          timeUpperBound,
          Math::PI/2,
          publicLocalState
        )
      )
      producedInfluences.add(
        DropMark.new(
          timeLowerBound,
          timeUpperBound,
          Mark.new(
            publicLocalState.getLocation.clone,
            nil
          )
        )
      )
    else
      producedInfluences.add(
        ChangeDirection.new(
          timeLowerBound,
          timeUpperBound,
          -Math::PI/2,
          publicLocalState
        )
      )
      producedInfluences.add(
        RemoveMark.new(
          timeLowerBound,
          timeUpperBound,
          perceivedData.getMarks.iterator.next.getContent
        )
      )
    end
  end
end</code></pre>
<h4 id="the-simulation-model-6">The simulation model</h4>
<p>The simulation model generates a turmite heading north at the location 10.5,10.5 with a speed of 1 and an acceleration of 0:</p>
<pre><code>class TurmiteSimulationModel &lt; AbstractLogoSimulationModel
  def generateAgents(p, levels)
      result =  AgentInitializationData.new
      turtle = TurtleFactory::generate(
        ConeBasedPerceptionModel.new(0, 2*Math::PI, false, true, false),
        TurmiteDecisionModel.new,
        AgentCategory.new(&quot;turmite&quot;, TurtleAgentCategory::CATEGORY),
        LogoEnvPLS::NORTH,
        1,
        0,
        10.5,
        10.5
      )
      result.agents.add(turtle)
      return result
    end
end</code></pre>
<h4 id="launch-the-html-runner-4">Launch the HTML runner</h4>
<pre><code>runner = Similar2LogoWebRunner.new
runner.config.setExportAgents(true)
runner.config.setExportMarks( true )
runner.initializeRunner(TurmiteSimulationModel.new(LogoSimulationParameters.new))
runner.showView
runner.addProbe(&quot;Real time matcher&quot;, RealTimeMatcherProbe.new(20))</code></pre>
<p>The main difference with the previous example is that in this case we want to observe turtles and marks.</p>
<h3 id="adding-user-defined-influence-reaction-model-and-gui-the-segregation-model-2"><a name="rsegregation"></a> Adding user-defined influence, reaction model and GUI: The segregation model</h3>
<p>The segregation model has been proposed by <a href="https://en.wikipedia.org/wiki/Thomas_Schelling">Thomas Schelling</a> in 1971 in his famous paper <a href="https://www.stat.berkeley.edu/~aldous/157/Papers/Schelling_Seg_Models.pdf">Dynamic Models of Segregation</a>. The goal of this model is to show that segregation can occur even if it is not wanted by the agents.</p>
<p>In our implementation of this model, turtles are located in the grid and at each step, compute an happiness index based on the similarity of other agents in their neighborhood. If this index is below a value, called here similarity rate, the turtle wants to move to an other location.</p>
<h4 id="model-parameters-9">Model parameters</h4>
<p>We define the following parameters and their default values.</p>
<pre><code>class SegregationSimulationParameters &lt; LogoSimulationParameters
  
  attr_accessor :similarityRate, :vacancyRate, :perceptionDistance
  def initialize
    
    @similarityRate = 3.0/8
  
    @vacancyRate = 0.05
  
    @perceptionDistance = Math::sqrt(2)
  end
  
end</code></pre>
<h4 id="model-specific-influence-2">Model-specific influence</h4>
<p>We define an influence called <code>Move</code> that is emitted by an agent who wants to move to another location. It is defined by a unique identifier, here “move”, and the state of the turtle that wants to move.</p>
<pre><code>class Move &lt; RegularInfluence
  
  attr_accessor :target
  def initialize( s, ns, target)
    super(&quot;move&quot;, LogoSimulationLevelList::LOGO, s, ns)
    @target = target
  end
  
end</code></pre>
<h4 id="decision-model-6">Decision model</h4>
<p>The decision model computes a happiness index based on the rate of turtles of different categories in its neighborhood. If the index is below the parameter <code>similarityRate</code>, the turtle emits a <code>Move</code> influence.</p>
<pre><code>class SegregationAgentDecisionModel &lt; AbstractAgtDecisionModel
  
  def initialize(parameters)
    super(LogoSimulationLevelList::LOGO)
    @parameters = parameters
  end
  
  def decide(
    timeLowerBound,
    timeUpperBound,
    globalState,
    publicLocalState,
    privateLocalState,
    perceivedData,
    producedInfluences
  )
    sr = 0.0
    perceivedData.turtles.each do |perceivedTurtle|
      if perceivedTurtle.content.categoryOfAgent.isA(publicLocalState.categoryOfAgent)
        sr+=1.0
      end
    end
    if !perceivedData.turtles.empty
      sr/= perceivedData.turtles.size
    end
    if sr &lt; @parameters.similarityRate
      producedInfluences.add(Move.new(timeLowerBound, timeUpperBound, publicLocalState))
    end
  end
end</code></pre>
<h4 id="reaction-model-2">Reaction model</h4>
<p>The reaction model handles the <code>Move</code> influences emitted by unhappy turtles. First, it identifies vacant places and moves the turtles that have emitted a <code>Move</code> influence. Note that if there is not enough vacant places, not all turtle wishes can be fulfilled.</p>
<pre><code>class SegregationReactionModel &lt; LogoDefaultReactionModel
  def makeRegularReaction(
      transitoryTimeMin,
      transitoryTimeMax,
      consistentState,
      regularInfluencesOftransitoryStateDynamics,
      remainingInfluences
    )
    if regularInfluencesOftransitoryStateDynamics.size &gt; 2
      specificInfluences = ArrayList.new
      vacantPlaces = ArrayList.new
      specificInfluences.addAll(regularInfluencesOftransitoryStateDynamics)
      PRNG.shuffle(specificInfluences)
      for x in 0..consistentState.publicLocalStateOfEnvironment.width()-1
        for y in 0..consistentState.publicLocalStateOfEnvironment.height()-1
          if consistentState.publicLocalStateOfEnvironment.getTurtlesAt(x, y).empty?
            vacantPlaces.add(Point2D::Double.new(x,y))
          end
        end
      end
      PRNG.shuffle(vacantPlaces)
      i = 0
      specificInfluences.each do |influence|
        if influence.getCategory() == &quot;move&quot;
          consistentState.publicLocalStateOfEnvironment.turtlesInPatches[influence.target.location.x.floor][influence.target.location.y.floor].clear()
          consistentState.publicLocalStateOfEnvironment.turtlesInPatches[vacantPlaces[i].x.floor][vacantPlaces[i].y.floor].add(influence.target)
          influence.target.setLocation(vacantPlaces[i])
          i+=1      
        end
        if i &gt;= vacantPlaces.size
          break
        end
      end
    end
  end 
end</code></pre>
<h4 id="simulation-model-4">Simulation model</h4>
<p>The simulation model generates the Logo level using the user-defined reaction model and a simple periodic time model. It also generates turtles of 2 different types (a and b) randomly in the grid with respect to the vacancy rate parameter.</p>
<pre><code>class SegregationSimulationModel &lt; AbstractLogoSimulationModel
  def generateLevels(p)
    logo = ExtendedLevel.new(
      p.initialTime,
      LogoSimulationLevelList::LOGO,
      PeriodicTimeModel.new(1,0, p.initialTime),
      SegregationReactionModel.new
    )
    levelList = LinkedList.new
    levelList.add(logo)
    return levelList
  end
  def generateAgents(p, levels)
     result =  AgentInitializationData.new
     t = &quot;&quot;
    for x in 0...p.gridWidth-1
      for y in 0..p.gridHeight-1
        if PRNG.randomDouble &gt;= p.vacancyRate
          if PRNG.randomBoolean
            t = &quot;a&quot;
          else
            t = &quot;b&quot;
          end
          turtle = TurtleFactory.generate(
            ConeBasedPerceptionModel.new(p.perceptionDistance, 2*Math::PI, true, false, false),
            SegregationAgentDecisionModel.new(p),
            AgentCategory.new(t, TurtleAgentCategory::CATEGORY),
            0,
            0,
            0,
            x,
            y
          )
          result.agents.add( turtle )
        end  
      end
    end
    return result
  end
end</code></pre>
<h4 id="html-gui-2">HTML GUI</h4>
<p>The GUI is defined in a variable called <code>segregationgui</code>.</p>
<pre><code>segregationgui = %{
    &lt;canvas id=&#39;grid_canvas&#39; class=&#39;center-block&#39; width=&#39;400&#39; height=&#39;400&#39;&gt;&lt;/canvas&gt;
    &lt;script type=&#39;text/javascript&#39;&gt;
        drawCanvas = function (data) {
            var json = JSON.parse(data),
                canvas = document.getElementById(&#39;grid_canvas&#39;),
                context = canvas.getContext(&#39;2d&#39;);
            context.clearRect(0, 0, canvas.width, canvas.height);
            for (var i = 0; i &lt; json.agents.length; i++) {
                var centerX = json.agents[i].x * canvas.width;
                var centerY = json.agents[i].y * canvas.height;
                var radius = 2;
                if (json.agents[i].t == &#39;a&#39;) {
                    context.fillStyle = &#39;red&#39;;
                } else {
                    context.fillStyle = &#39;blue&#39;;
                }
                context.beginPath();
                context.arc(centerX, centerY, radius, 0, 2 * Math.PI, false);
                context.fill();
            }
        }
&lt;/script&gt;}</code></pre>
<h4 id="launch-the-html-runner-5">Launch the HTML runner</h4>
<p>Finally, we launche the web server with the above described GUI.</p>
<pre><code>runner = Similar2LogoWebRunner.new
runner.config.setCustomHtmlBodyFromString(segregationgui)
runner.config.setExportAgents(true)
runner.initializeRunner(SegregationSimulationModel.new(SegregationSimulationParameters.new))
runner.showView</code></pre>
<h2 id="kotlin-examples"><a name="kexamples"></a> Kotlin Examples</h2>
<p>In the following we comment the examples written in Kotlin distributed with Similar2Logo. Each example introduces a specific feature.</p>
<ul>
<li><p><a href="#kpassive">A first example with a passive turtle</a></p></li>
<li><p><a href="#kboids">Adding a user-defined decision model to the turtles: The boids model</a></p></li>
<li><p><a href="#kturmite">Dealing with marks: the turmite model</a></p></li>
<li><p><a href="#kmultiturmite">Adding an interaction and a user-defined reaction model: The multiturmite model</a></p></li>
<li><p><a href="#ksegregation">Adding user-defined influence, reaction model and GUI: The segregation model</a></p></li>
</ul>
<h3 id="a-first-example-with-a-passive-turtle-3"><a name="kpassive"></a> A first example with a passive turtle</h3>
<p>First we consider a simple example with a single passive agent. The example source code is located in the package <code>fr.univ_artois.lgi2a.similar2logo.examples.passive</code>. It contains 3 classes:</p>
<ul>
<li><p><code>PassiveTurtleSimulationParameters</code>, that defines the parameters of the model. This class inherits from <code>LogoSimulationParameters</code>.</p></li>
<li><p><code>PassiveTurtleSimulationModel</code>, that defines the simulation model, i.e, the initial state of the simulation. This class inherits from <code>AbstractLogoSimulationModel</code>.</p></li>
<li><p><code>PassiveTurtleSimulationMain</code>, the main class of the simulation.</p></li>
</ul>
<h4 id="model-parameters-10">Model parameters</h4>
<p>The class <code>LogoSimulationParameters</code> defines the generic parameters of a Logo-like simulation (environment size, topology, etc.).</p>
<p>The class <code>PassiveTurtleSimulationParameters</code> contains the parameters specific to this model.</p>
<pre><code>class PassiveTurtleSimulationParameters : LogoSimulationParameters() {
    
    @Parameter(
       name = &quot;initial x&quot;, 
       description = &quot;the initial position of the turtle on the x axis&quot;
    )
    var  initialX = 10.0;
    
    @Parameter(
       name = &quot;initial y&quot;, 
       description = &quot;the initial position of the turtle on the y axis&quot;
    )
    var initialY = 10.0
    
    @Parameter(
       name = &quot;initial speed&quot;, 
       description = &quot;the initial speed of the turtle&quot;
    )
    var initialSpeed = 0.1
    
    @Parameter(
       name = &quot;initial acceleration&quot;, 
       description = &quot;the initial acceleration of the turtle&quot;
    )
    var initialAcceleration = 0.0
    
    @Parameter(
       name = &quot;initial direction&quot;, 
       description = &quot;the initial direction of the turtle&quot;
    )
    var initialDirection = LogoEnvPLS.NORTH
}</code></pre>
<h4 id="the-simulation-model-7">The simulation model</h4>
<p>The class <a href="http://www.lgi2a.univ-artois.fr/~morvan/similar2logo/docs/api/fr/univ_artois/lgi2a/similar2logo/kernel/initializations/AbstractLogoSimulationModel.html">AbstractLogoSimulationModel</a> defines a generic simulation model of a Similar2Logo simulation. We must implement the <code>generateAgents</code> function to describe the initial state of our passive turtle.</p>
<pre><code>class PassiveTurtleSimulationModel(parameters : LogoSimulationParameters)  : AbstractLogoSimulationModel(parameters) {
    
     override fun generateAgents(
         parameters : ISimulationParameters,
         levels : Map&lt;LevelIdentifier, ILevel&gt; 
     ) : AgentInitializationData { 
         var castedParameters : PassiveTurtleSimulationParameters = parameters as PassiveTurtleSimulationParameters
         var result = AgentInitializationData()
         var turtle = TurtleFactory.generate(
            EmptyPerceptionModel(),
            PassiveTurtleDecisionModel(),
            AgentCategory(&quot;passive&quot;, TurtleAgentCategory.CATEGORY),
            castedParameters.initialDirection,
            castedParameters.initialSpeed,
            castedParameters.initialAcceleration,
            castedParameters.initialX,
            castedParameters.initialY
        )
        result.getAgents().add(turtle)
        return result
    }
        
}</code></pre>
<p>Note that it is not necessary to define any class related to our turtle. Since it is passive, we use a predefined decision model called <code>PassiveTurtleDecisionModel</code>.</p>
<p>Since the turtle does not need to perceive anything, as a perception module, we use the empty perception model <code>EmptyPerceptionModel</code>.</p>
<h4 id="the-main-class-4">The Main class</h4>
<p>In the main class, the simulation model is created and the HTML runner is launched and configured. Here, only the turtles are displayed.</p>
<p>Finally, the probe <code>RealTimeMatcherProbe</code> is added to the runner to slow down the simulation so that its execution speed matches a specific factor of N steps per second.</p>
<p>The <code>main</code> function contains the following code:</p>
<pre><code>fun main(args: Array&lt;String&gt;) {
    var runner = Similar2LogoWebRunner()
    // Configuration of the runner
    runner.getConfig().setExportAgents(true)
    // Creation of the model
    var model = PassiveTurtleSimulationModel(PassiveTurtleSimulationParameters())
    // Initialize the runner with the model
    runner.initializeRunner(model)
    // Add other probes to the engine
    runner.addProbe(&quot;Real time matcher&quot;, RealTimeMatcherProbe(20.0))
    // Open the GUI.
    runner.showView()
}</code></pre>
<h3 id="adding-a-user-defined-decision-module-to-the-turtles-the-boids-model-2"><a name="kboids"></a> Adding a user-defined decision module to the turtles: The boids model</h3>
<p>The <a href="https://en.wikipedia.org/wiki/Boids">boids</a> (bird-oid) model has been invented by <a href="https://en.wikipedia.org/wiki/Craig_Reynolds_(computer_graphics)">Graig Reynolds</a> in 1986 to simulate flocking behavior of birds. It is based on 3 principles:</p>
<ul>
<li><p>separation: boids tend to avoid other boids that are too close,</p></li>
<li><p>alignment: boids tend to align their velocity to boids that are not too close and not too far away,</p></li>
<li><p>cohesion: bois tend to move towards boids that are too far away.</p></li>
</ul>
<p>While these rules are essentially heuristic, they can be implemented defining three areas for each principle.</p>
<ul>
<li><p>Boids change their orientation to get away from other boids in the repulsion area,</p></li>
<li><p>Boids change their orientation and speed to match those of other boids in the orientation area,</p></li>
<li><p>Boids change their orientation to get to other boids in the attraction area.</p></li>
</ul>
<p>An implementation of such model is located in the package <code>fr.univ_artois.lgi2a.similar2logo.examples.boids</code> which contains 4 classes:</p>
<ul>
<li><p><code>BoidsSimulationParameters</code>, that defines the parameters of the model. This class inherits from <code>LogoSimulationParameters</code>,</p></li>
<li><p><code>BoidDecisionModel</code>, that defines the decision model of the boids. This class inherits from <code>AbstractAgtDecisionModel</code>.</p></li>
<li><p><code>BoidsSimulationModel</code>, that defines the simulation model. This class inherits from <code>AbstractLogoSimulationModel</code>.</p></li>
<li><p><code>BoidsSimulationMain</code>, the main class.</p></li>
</ul>
<h4 id="model-parameters-11">Model parameters</h4>
<p>The <code>BoidsSimulationParameters</code> class contains the following parameters:</p>
<pre><code>class BoidsSimulationParameters : LogoSimulationParameters() {


    @Parameter(
            name = &quot;repulsion distance&quot;,
            description = &quot;the repulsion distance&quot;
    )
    var repulsionDistance = 6.0

    @Parameter(
            name = &quot;orientation distance&quot;,
            description = &quot;the orientation distance&quot;
    )
    var orientationDistance = 10.0

    @Parameter(
            name = &quot;attraction distance&quot;,
            description = &quot;the attraction distance&quot;
    )
    var attractionDistance = 14.0

    @Parameter(
            name = &quot;repulsion weight&quot;,
            description = &quot;the repulsion weight&quot;
    )
    var repulsionWeight = 1.0

    @Parameter(
            name = &quot;orientation weight&quot;,
            description = &quot;the orientation weight&quot;
    )
    var orientationWeight = 1.0

    @Parameter(
            name = &quot;attraction weight&quot;,
            description = &quot;the attraction weight&quot;
    )
    var attractionWeight = 1.0

    @Parameter(
            name = &quot;maximal initial speed&quot;,
            description = &quot;the maximal initial speed of boids&quot;
    )
    var maxInitialSpeed = 2.0

    @Parameter(
            name = &quot;minimal initial speed&quot;,
            description = &quot;the minimal initial speed of boids&quot;
    )
    var minInitialSpeed = 1.0

    @Parameter(
            name = &quot;perception angle&quot;,
            description = &quot;the perception angle of the boids in rad&quot;
    )
    var perceptionAngle = Math.PI

    @Parameter(
            name = &quot;number of agents&quot;,
            description = &quot;the number of agents in the simulation&quot;
    )
    var nbOfAgents = 200

    @Parameter(
            name = &quot;max angular speed&quot;,
            description = &quot;the maximal angular speed of the boids in rad/step&quot;
    )
    var maxAngle = Math.PI / 8

}</code></pre>
<h4 id="the-behavior-of-the-boids-1">The behavior of the boids</h4>
<p>The decision model consists in changing the direction and speed of the boids according to the previously described rules. To define a decision model, the modeler must define a class that extends <code>AbstractAgtDecisionModel</code> and implement the <code>decide</code> function.</p>
<pre><code>class BoidDecisionModel(parameters: BoidsSimulationParameters) : AbstractAgtDecisionModel(LogoSimulationLevelList.LOGO) {

    var parameters = parameters

    override fun decide(
            timeLowerBound: SimulationTimeStamp,
            timeUpperBound: SimulationTimeStamp,
            globalState: IGlobalState,
            publicLocalState: ILocalStateOfAgent,
            privateLocalState: ILocalStateOfAgent,
            perceivedData: IPerceivedData,
            producedInfluences: InfluencesMap
    ) {
        var castedPublicLocalState = publicLocalState as TurtlePLSInLogo
        var castedPerceivedData = perceivedData as TurtlePerceivedData
        if (!castedPerceivedData.getTurtles().isEmpty()) {
            var orientationSpeed = 0.0
            var nbOfTurtlesInOrientationArea = 0
            var meanAngle = MeanAngle()
            for (perceivedTurtle in castedPerceivedData.getTurtles()) {
                if (perceivedTurtle.getDistanceTo() &lt;= this.parameters.repulsionDistance) {
                    meanAngle.add(
                            castedPublicLocalState.getDirection() - perceivedTurtle.getDirectionTo(),
                            parameters.repulsionWeight
                    )
                } else if (perceivedTurtle.getDistanceTo() &lt;= this.parameters.orientationDistance) {
                    meanAngle.add(
                            perceivedTurtle.getContent().getDirection() - castedPublicLocalState.getDirection(),
                            parameters.orientationWeight
                    )
                    orientationSpeed += perceivedTurtle.getContent().getSpeed() - castedPublicLocalState.getSpeed()
                    nbOfTurtlesInOrientationArea++
                } else if (perceivedTurtle.getDistanceTo() &lt;= this.parameters.attractionDistance) {
                    meanAngle.add(
                            perceivedTurtle.getDirectionTo() - castedPublicLocalState.getDirection(),
                            parameters.attractionWeight
                    )
                }
            }
            var dd = meanAngle.value()
            if (!MathUtil.areEqual(dd, 0.0)) {
                if (dd &gt; parameters.maxAngle) {
                    dd = parameters.maxAngle
                } else if (dd &lt; -parameters.maxAngle) {
                    dd = -parameters.maxAngle
                }
                producedInfluences.add(
                        ChangeDirection(
                                timeLowerBound,
                                timeUpperBound,
                                dd,
                                castedPublicLocalState
                        )
                )
            }
            if (nbOfTurtlesInOrientationArea &gt; 0) {
                orientationSpeed /= nbOfTurtlesInOrientationArea;
                producedInfluences.add(
                        ChangeSpeed(
                                timeLowerBound,
                                timeUpperBound,
                                orientationSpeed,
                                castedPublicLocalState
                        )
                )
            }
        }
    }

}</code></pre>
<h4 id="the-simulation-model-8">The simulation model</h4>
<p>In the simulation model defined in our example, boids are initially randomly located in the environment with a random orientation and speed.</p>
<pre><code>class BoidsSimulationModel(parameters: LogoSimulationParameters) : AbstractLogoSimulationModel(parameters) {

    override fun generateAgents(
            parameters: ISimulationParameters,
            levels: Map&lt;LevelIdentifier, ILevel&gt;
    ): AgentInitializationData {
        var castedParameters = parameters as BoidsSimulationParameters
        var result = AgentInitializationData()
        for (i in 0..castedParameters.nbOfAgents) {
            result.getAgents().add(generateBoid(castedParameters))
        }
        return result
    }

    fun generateBoid(p: BoidsSimulationParameters): IAgent4Engine {
        return TurtleFactory.generate(
                ConeBasedPerceptionModel(
                        p.attractionDistance, p.perceptionAngle, true, false, false
                ),
                BoidDecisionModel(p),
                AgentCategory(&quot;b&quot;, TurtleAgentCategory.CATEGORY),
                PRNG.randomAngle(),
                p.minInitialSpeed + PRNG.randomDouble() * (
                        p.maxInitialSpeed - p.minInitialSpeed
                        ),
                0.0,
                PRNG.randomDouble() * p.gridWidth,
                PRNG.randomDouble() * p.gridHeight
        )
    }

}</code></pre>
<h4 id="the-main-class-5">The main class</h4>
<p>In the main class, such as in the previous example, the simulation model is created and the HTML runner is launched and configured. The <code>main</code> function contains the following code:</p>
<pre><code>fun main(args: Array&lt;String&gt;) {
    var runner = Similar2LogoWebRunner()
    // Configuration of the runner
    runner.getConfig().setExportAgents(true)
    // Creation of the model
    var model = BoidsSimulationModel(BoidsSimulationParameters())
    // Initialize the runner with the model
    runner.initializeRunner(model)
    // Add other probes to the engine
    // Open the GUI.
    runner.showView()
}</code></pre>
<p>The main class is very similar to the previous example. Only the simulation model has been changed.</p>
<h3 id="dealing-with-marks-the-turmite-model-3"><a name="kturmite"></a> Dealing with marks: the turmite model</h3>
<p>The <a href="https://en.wikipedia.org/wiki/Langton&#39;s_ant">turmite model</a>, developed by <a href="https://en.wikipedia.org/wiki/Christopher_Langton">Christopher Langton</a> in 1986, is a very simple mono-agent model that exhibits an emergent behavior. It is based on 2 rules:</p>
<ul>
<li><p>If the turmite is on a patch that does not contain a mark, it turns right, drops a mark, and moves forward,</p></li>
<li><p>If the turmite is on a patch that contains a mark, it turns left, removes the mark, and moves forward.</p></li>
</ul>
<p>The example source code is located in the package <code>fr.univ_artois.lgi2a.similar2logo.examples.turmite</code>. It contains 3 classes:</p>
<ul>
<li><p><code>TurmiteDecisionModel</code> that defines the decision model of the turmites,</p></li>
<li><p><code>TurmiteSimulationModel</code> that defines the simulation model,</p></li>
<li><p><code>TurmiteSimulationMain</code>, the main class of the simulation.</p></li>
</ul>
<h4 id="the-decision-model-2">The decision model</h4>
<p>The decision model implements the above described rules :</p>
<pre><code>class TurmiteDecisionModel : AbstractAgtDecisionModel(LogoSimulationLevelList.LOGO) {

    override fun decide(
            timeLowerBound: SimulationTimeStamp,
            timeUpperBound: SimulationTimeStamp,
            globalState: IGlobalState,
            publicLocalState: ILocalStateOfAgent,
            privateLocalState: ILocalStateOfAgent,
            perceivedData: IPerceivedData,
            producedInfluences: InfluencesMap
    ) {
        var castedPublicLocalState = publicLocalState as TurtlePLSInLogo
        var castedPerceivedData = perceivedData as TurtlePerceivedData
        if(castedPerceivedData.getMarks().isEmpty()) {
            producedInfluences.add(
                ChangeDirection(
                    timeLowerBound,
                    timeUpperBound,
                    Math.PI/2,
                    castedPublicLocalState
                )
            )
            producedInfluences.add(
                DropMark(
                    timeLowerBound,
                    timeUpperBound,
                    Mark&lt;Any&gt;(
                        castedPublicLocalState.getLocation().clone() as Point2D,
                        null
                    )
                )
            )
        } else {
            producedInfluences.add(
                ChangeDirection(
                    timeLowerBound,
                    timeUpperBound,
                    -Math.PI/2,
                    castedPublicLocalState
                )
            )
            
            producedInfluences.add(
                RemoveMark(
                    timeLowerBound,
                    timeUpperBound,
                    castedPerceivedData.getMarks().iterator().next().getContent()
                )
            )
        }
    }

}</code></pre>
<h4 id="the-simulation-model-9">The simulation model</h4>
<p>The simulation model generates a turmite heading north at the location 10.5,10.5 with a speed of 1 and an acceleration of 0:</p>
<pre><code>class TurmiteSimulationModel(parameters: LogoSimulationParameters) : AbstractLogoSimulationModel(parameters) {

    override fun generateAgents(
            parameters: ISimulationParameters,
            levels: Map&lt;LevelIdentifier, ILevel&gt;
    ): AgentInitializationData {
        var result = AgentInitializationData()
        var turtle = TurtleFactory.generate(
                ConeBasedPerceptionModel(0.0, 2 * Math.PI, false, true, false),
                TurmiteDecisionModel(),
                AgentCategory(&quot;turmite&quot;, TurtleAgentCategory.CATEGORY),
                LogoEnvPLS.NORTH,
                1.0,
                0.0,
                10.5,
                10.5
        )
        result.getAgents().add(turtle)
        return result
    }

}</code></pre>
<h4 id="the-main-class-6">The main class</h4>
<p>In the main function, such as in the previous example, the simulation model is created and the HTML runner is launched and configured. The <code>main</code> function contains the following code:</p>
<pre><code>fun main(args: Array&lt;String&gt;) {
    var runner = Similar2LogoWebRunner()
    // Configuration of the runner
    runner.getConfig().setExportAgents(true)
    runner.getConfig().setExportMarks(true)
    // Creation of the model
    var model = TurmiteSimulationModel(LogoSimulationParameters())
    // Initialize the runner with the model
    runner.initializeRunner(model)
    // Add other probes to the engine
    runner.addProbe(&quot;Real time matcher&quot;, RealTimeMatcherProbe(20.0))
    // Open the GUI.
    runner.showView()
}</code></pre>
<p>The main difference with the previous example is that in this case we want to observe turtles and marks.</p>
<h3 id="adding-an-interaction-and-a-user-defined-reaction-model-the-multiturmite-model-1"><a name="kmultiturmite"></a> Adding an interaction and a user-defined reaction model: The multiturmite model</h3>
<p>The goal of this example is to implement the multiturmite model proposed by <a href="http://www.loria.fr/~fates/">N. Fatès</a> and <a href="http://www.loria.fr/~chevrier/">V. Chevrier</a> in <a href="http://www.ifaamas.org/Proceedings/aamas2010/pdf/01%20Full%20Papers/11_04_FP_0210.pdf">this paper</a>. It extends the traditional <a href="http://en.wikipedia.org/wiki/Langton%27s_ant">Langton’s ant model</a> by specifying what happens when conflicting influences (removing or dropping a mark to the same location) are detected. The following policy is applied:</p>
<ul>
<li><p>if the parameter <code>dropMark</code> is <code>true</code>, the dropping influence takes precedent over the removing one and reciprocally.</p></li>
<li><p>if the parameter <code>removeDirectionChange</code> is <code>true</code>, direction changes are not taken into account.</p></li>
</ul>
<p>It allows to define 4 different reaction models according to these parameters.</p>
<p>This model is located in the <code>fr.univ_artois.lgi2a.similar2logo.examples.multiturmite</code> package and contains at least 5 classes:</p>
<ul>
<li><p><code>MultiTurmiteSimulationParameters</code>, that contains the parameters of the model,</p></li>
<li><p><code>TurmiteInteraction</code>, that defines an interaction between multiple turmites,</p></li>
<li><p><code>MultiTurmiteReactionModel</code>, that extends <code>LogoDefaultReactionModel</code> and defines the reaction model, i.e., the way influences are handled,</p></li>
<li><p><code>MultiTurmiteSimulationModel</code> that defines the simulation model,</p></li>
<li><p>Different main classes that define a specific initial configuration of the simulation, in our case, based on the ones described by <a href="http://www.loria.fr/~fates/">N. Fatès</a> and <a href="http://www.loria.fr/~chevrier/">V. Chevrier</a> in <a href="http://www.ifaamas.org/Proceedings/aamas2010/pdf/01%20Full%20Papers/11_04_FP_0210.pdf">their paper</a>.</p></li>
</ul>
<h4 id="model-parameters-12">Model parameters</h4>
<p>The model parameters are defined in the class <code>MultiTurmiteSimulationParameters</code>. It defines how influences are handled according to the previously defined policy, the number of turmites and their initial locations.</p>
<pre><code>class MultiTurmiteSimulationParameters : LogoSimulationParameters() {

    @Parameter(
            name = &quot;remove direction change&quot;,
            description = &quot;if checked, direction changes are not taken into account when two turtles want to modify the same patch&quot;
    )
    var removeDirectionChange = true

    @Parameter(
            name = &quot;inverse mark update&quot;,
            description = &quot;if checked, the output of turtle actions is inversed when two turtles want to modify the same patch&quot;
    )
    var inverseMarkUpdate = true

    @Parameter(
            name = &quot;number of turmites&quot;,
            description = &quot;the  number of turmites in the environment&quot;
    )
    var nbOfTurmites = 2

    @Parameter(
            name = &quot;initial locations&quot;,
            description = &quot;the  initial locations of turmites&quot;
    )
    var initialLocations = ArrayList&lt;Point2D&gt;()

    @Parameter(
            name = &quot;initial directions&quot;,
            description = &quot;the initial directions of turmites&quot;
    )
    var initialDirections = ArrayList&lt;Double&gt;()

}</code></pre>
<h4 id="the-reaction-model-1">The reaction model</h4>
<p>In the previous example, the influence management relies on the default reaction model defined in the class <code>LogoDefaultReactionModel</code>. Now, we want to handle some influences manually. To do so, we have to define a class <code>MultiTurmiteReactionModel</code> that inherits from <code>LogoDefaultReactionModel</code>. This class has one property: the parameters of the simulation.</p>
<p>What we have to do is to change the behavior of the <code>makeRegularReaction</code> function. A generic stub of a specific reaction model is given below:</p>
<pre><code>override fun makeRegularReaction(
            transitoryTimeMin: SimulationTimeStamp,
            transitoryTimeMax: SimulationTimeStamp,
            consistentState: ConsistentPublicLocalDynamicState,
            regularInfluencesOftransitoryStateDynamics: Set&lt;IInfluence&gt;,
            remainingInfluences: InfluencesMap
    ) {
        var nonSpecificInfluences = LinkedHashSet&lt;IInfluence&gt;()
        
        //Management of specific influences
        
        super.makeRegularReaction(transitoryTimeMin, transitoryTimeMax, consistentState, nonSpecificInfluences, remainingInfluences)
    }</code></pre>
<p>The idea is to identify the influences that do not trigger a generic reaction and manage them separately. Non specific influences are handled by the regular reaction.</p>
<p>In this case, specific influences represents collisions between turtle decisions. We define a class <code>TurmiteInteraction</code> that explicitly represent possible collisions for each location.</p>
<pre><code>class TurmiteInteraction {
    
    var dropMarks = LinkedHashSet&lt;DropMark&gt;()
    var removeMarks = LinkedHashSet&lt;RemoveMark&gt;()
    var changeDirections = LinkedHashSet&lt;ChangeDirection&gt;()
    
    fun isColliding(): Boolean {
        return removeMarks.size &gt; 1|| dropMarks.size &gt; 1;
    }
    
}</code></pre>
<p>Then, it is easy to implement the reaction model whether the influences are colliding or not:</p>
<pre><code>class MultiTurmiteReactionModel(parameters: MultiTurmiteSimulationParameters) : LogoDefaultReactionModel() {

    var parameters = parameters

    override fun makeRegularReaction(
            transitoryTimeMin: SimulationTimeStamp,
            transitoryTimeMax: SimulationTimeStamp,
            consistentState: ConsistentPublicLocalDynamicState,
            regularInfluencesOftransitoryStateDynamics: Set&lt;IInfluence&gt;,
            remainingInfluences: InfluencesMap
    ) {
        var nonSpecificInfluences = LinkedHashSet&lt;IInfluence&gt;()
        var collisions = LinkedHashMap&lt;Point2D, TurmiteInteraction&gt;()

        //Organize influences by location and type
        for (influence in regularInfluencesOftransitoryStateDynamics) {
            if (influence.category.equals(DropMark.CATEGORY)) {
                var castedDropInfluence = influence as DropMark
                if (!collisions.containsKey(castedDropInfluence.mark.location)) {
                    collisions.put(
                            castedDropInfluence.mark.location,
                            TurmiteInteraction()
                    )
                }
                collisions.get(castedDropInfluence.mark.location)?.dropMarks?.add(castedDropInfluence)

            } else if (influence.category.equals(RemoveMark.CATEGORY)) {
                var castedRemoveInfluence = influence as RemoveMark
                if (!collisions.containsKey(castedRemoveInfluence.mark.location)) {
                    collisions.put(
                            castedRemoveInfluence.mark.location,
                            TurmiteInteraction()
                    )
                }
                collisions.get(castedRemoveInfluence.mark.location)?.removeMarks?.add(castedRemoveInfluence)
            } else if (influence.category.equals(ChangeDirection.CATEGORY)) {
                var castedChangeDirectionInfluence = influence as ChangeDirection
                if (!collisions.containsKey(castedChangeDirectionInfluence.target.location)) {
                    collisions.put(
                            castedChangeDirectionInfluence.target.location,
                            TurmiteInteraction()
                    )
                }
                collisions.get(castedChangeDirectionInfluence.target.location)?.changeDirections?.add(castedChangeDirectionInfluence)
            } else {
                nonSpecificInfluences.add(influence)
            }
        }

        for (collision in collisions.values) {
            if (collision.isColliding()) {
                if (!collision.dropMarks.isEmpty() &amp;&amp; !this.parameters.inverseMarkUpdate) {
                    nonSpecificInfluences.add(
                            collision.dropMarks.iterator().next()
                    )
                }
                if (!collision.removeMarks.isEmpty() &amp;&amp; !this.parameters.inverseMarkUpdate) {
                    nonSpecificInfluences.add(
                            collision.removeMarks.iterator().next()
                    )
                }
                if (!this.parameters.removeDirectionChange) {
                    nonSpecificInfluences.addAll(collision.changeDirections)
                }
            } else {
                nonSpecificInfluences.addAll(collision.changeDirections)
                if (!collision.dropMarks.isEmpty()) {
                    nonSpecificInfluences.add(collision.dropMarks.iterator().next())
                }
                if (!collision.removeMarks.isEmpty()) {
                    nonSpecificInfluences.add(collision.removeMarks.iterator().next())
                }
            }
        }

        super.makeRegularReaction(transitoryTimeMin, transitoryTimeMax, consistentState, nonSpecificInfluences, remainingInfluences)
    }
}
</code></pre>
<h4 id="the-simulation-model-10">The simulation model</h4>
<p>The simulation model of this example is located in the class <code>MultiTurmiteSimulationModel</code>.</p>
<p>Such as in the previous example, we have to redefine the function <code>generateAgents</code> to specify the initial population of agents of the simulation. However, contrary to the previous examples, we have to redefine the function <code>generateLevels</code> to specify the reaction model we use:</p>
<pre><code>class MultiTurmiteSimulationModel(parameters: LogoSimulationParameters) : AbstractLogoSimulationModel(parameters) {

    
    override fun generateLevels(
            simulationParameters: ISimulationParameters
    ): List&lt;ILevel&gt; {
        var logo = ExtendedLevel(
                simulationParameters.initialTime,
                LogoSimulationLevelList.LOGO,
                PeriodicTimeModel(
                        1,
                        0,
                        simulationParameters.initialTime
                ),
                MultiTurmiteReactionModel(simulationParameters as MultiTurmiteSimulationParameters)
        )
        var levelList = LinkedList&lt;ILevel&gt;()
        levelList.add(logo)
        return levelList
    }
    
    override fun generateAgents(
            parameters: ISimulationParameters,
            levels: Map&lt;LevelIdentifier, ILevel&gt;
    ): AgentInitializationData {
        var result = AgentInitializationData()
        var castedSimulationParameters = simulationParameters as MultiTurmiteSimulationParameters
        if(castedSimulationParameters.initialLocations.isEmpty()) {
            for(i in 1..castedSimulationParameters.nbOfTurmites) {
                var turtle = TurtleFactory.generate(
                    ConeBasedPerceptionModel(0.0, 2*Math.PI, false, true, false),
                    TurmiteDecisionModel(),
                    AgentCategory(&quot;turmite&quot;, TurtleAgentCategory.CATEGORY),
                    randomDirection(),
                    1.0,
                    0.0,
                    Math.floor(PRNG.randomDouble()*castedSimulationParameters.gridWidth),
                    Math.floor(PRNG.randomDouble()*castedSimulationParameters.gridHeight)
                )
                result.getAgents().add( turtle )
            }
        } else {
            if(
                castedSimulationParameters.nbOfTurmites != castedSimulationParameters.initialDirections.size ||
                castedSimulationParameters.nbOfTurmites != castedSimulationParameters.initialLocations.size
            ) {
                throw UnsupportedOperationException(&quot;Inital locations and directions must be specified for each turmite&quot;)
            }
            for(i in 0..castedSimulationParameters.nbOfTurmites-1) {
                var turtle = TurtleFactory.generate(
                    ConeBasedPerceptionModel(0.0, 2*Math.PI, false, true, false),
                    TurmiteDecisionModel(),
                    AgentCategory(&quot;turmite&quot;, TurtleAgentCategory.CATEGORY),
                    castedSimulationParameters.initialDirections[i],
                    1.0,
                    0.0,
                    castedSimulationParameters.initialLocations[i].x,
                    castedSimulationParameters.initialLocations[i].y
                )
                result.getAgents().add( turtle )
            }
        }
        return result
    }
    
    fun randomDirection(): Double {
        var rand = PRNG.randomDouble()
        if(rand &lt; 0.25) {
            return LogoEnvPLS.NORTH
        } else if ( rand &lt; 0.5 ) {
            return LogoEnvPLS.WEST
        } else if ( rand &lt; 0.75 ) {
            return LogoEnvPLS.SOUTH
        }
        return LogoEnvPLS.EAST
    }

}</code></pre>
<h4 id="the-main-file">The Main file</h4>
<p>The main file contains the following code:</p>
<pre><code>fun main(args: Array&lt;String&gt;) {
    var runner = Similar2LogoWebRunner()
    // Configuration of the runner
    runner.config.setExportAgents(true)
    runner.config.setExportMarks(true)
    // Creation of the model
    var parameters = MultiTurmiteSimulationParameters()
    parameters.apply {
        nbOfTurmites = 2
        initialLocations.add(
                Point2D.Double(
                        Math.floor(parameters.gridWidth / 2.0),
                        Math.floor(parameters.gridHeight / 2.0)
                )
        )
        parameters.initialDirections.add(LogoEnvPLS.NORTH)
        parameters.initialLocations.add(
                Point2D.Double(
                        Math.floor(parameters.gridWidth / 2.0),
                        Math.floor(parameters.gridHeight / 2.0) + 1
                )
        )
        parameters.initialDirections.add(LogoEnvPLS.NORTH)
    }
    var model = MultiTurmiteSimulationModel(parameters)
    // Initialize the runner with the model
    runner.initializeRunner(model)
    // Add other probes to the engine
    runner.addProbe(&quot;Real time matcher&quot;, RealTimeMatcherProbe(20.0))
    // Open the GUI.
    runner.showView()
}</code></pre>
<p>In this case, we create a specific instance of the multiturmite model with 2 turmites. This configuration described by <a href="http://www.loria.fr/~fates/">N. Fatès</a> and <a href="http://www.loria.fr/~chevrier/">V. Chevrier</a> in <a href="http://www.ifaamas.org/Proceedings/aamas2010/pdf/01%20Full%20Papers/11_04_FP_0210.pdf">their paper</a> produces interesting and distinctive emergent behaviors according to the values of <code>dropMark</code> and <code>removeDirectionChange</code> parameters.</p>
<p>Such as in the previous example, we want to observe the turtles and the marks.</p>
<h3 id="adding-user-defined-influence-reaction-model-and-gui-the-segregation-model-3"><a name="ksegregation"></a> Adding user-defined influence, reaction model and GUI: The segregation model</h3>
<p>The segregation model has been proposed by <a href="https://en.wikipedia.org/wiki/Thomas_Schelling">Thomas Schelling</a> in 1971 in his famous paper <a href="https://www.stat.berkeley.edu/~aldous/157/Papers/Schelling_Seg_Models.pdf">Dynamic Models of Segregation</a>. The goal of this model is to show that segregation can occur even if it is not wanted by the agents.</p>
<p>In our implementation of this model, turtles are located in the grid and at each step, compute an happiness index based on the similarity of other agents in their neighborhood. If this index is below a value, called here similarity rate, the turtle wants to move to an other location.</p>
<p>The segregation simulation source code is located in the package <code>fr.univ_artois.lgi2a.similar2logo.examples.segregation</code>. It contains 6 classes</p>
<ul>
<li><p><code>SegregationSimulationParameters</code> that extends <code>LogoSimulationParameters</code>, that contains the parameters of the simulation.</p></li>
<li><p><code>Move</code> that extends <code>RegularInfluence</code>, representing a model-specific influence, emitted by an agent who wants to move to another location.</p></li>
<li><p><code>SegregationAgentDecisionModel</code> that extends <code>AbstractAgtDecisionModel</code>, representing the decision model of our turtles.</p></li>
<li><p><code>SegregationReactionModel</code> that extends <code>LogoDefaultReactionModel</code>, representing the model-specific reaction model. It defines how <code>Move</code> influences are handled.</p></li>
<li><p>a class <code>SegregationSimulationModel</code> that extends <code>AbstractLogoSimulationModel</code>, representing the simulation model, i.e., the initial state of the simulation.</p></li>
<li><p>the main class of the simulation <code>SegregationSimulationMain</code>.</p></li>
<li><p>a HTML file <code>segregationgui.html</code>, that contains the GUI of the simulation.</p></li>
</ul>
<h4 id="model-parameters-13">Model parameters</h4>
<p>The model parameters are defined in the class <code>SegregationSimulationParameters</code>. It contains the following parameters:</p>
<pre><code>class SegregationSimulationParameters : LogoSimulationParameters() {

    @Parameter(
            name = &quot;similarity rate&quot;,
            description = &quot;the rate of same-color turtles that each turtle wants among its neighbors&quot;
    )
    var similarityRate = 3.0 / 8

    @Parameter(
            name = &quot;vacancy rate&quot;,
            description = &quot;the rate of vacant settling places&quot;
    )
    var vacancyRate = 0.05

    @Parameter(
            name = &quot;perception distance&quot;,
            description = &quot;the perception distance of agents&quot;
    )
    var perceptionDistance = Math.sqrt(2.0)

}</code></pre>
<h4 id="model-specific-influence-3">Model-specific influence</h4>
<p>We define an influence called <code>Move</code> that is emitted by an agent who wants to move to another location. It is defined by a unique identifier, here “move”, and the state of the turtle that wants to move.</p>
<pre><code>class Move(
        timeLowerBound: SimulationTimeStamp,
        timeUpperBound: SimulationTimeStamp,
        target: TurtlePLSInLogo) :
        RegularInfluence(&quot;move&quot;, LogoSimulationLevelList.LOGO, timeLowerBound, timeUpperBound) {

    var target = target

}</code></pre>
<h4 id="decision-model-7">Decision model</h4>
<p>The decision model computes a happiness index based on the rate of turtles of different categories in its neighborhood. If the index is below the parameter <code>similarityRate</code>, the turtle emits a <code>Move</code> influence.</p>
<pre><code>class SegregationAgentDecisionModel(parameters: SegregationSimulationParameters) : AbstractAgtDecisionModel(LogoSimulationLevelList.LOGO) {

    var parameters = parameters

    override fun decide(
            timeLowerBound: SimulationTimeStamp,
            timeUpperBound: SimulationTimeStamp,
            globalState: IGlobalState,
            publicLocalState: ILocalStateOfAgent,
            privateLocalState: ILocalStateOfAgent,
            perceivedData: IPerceivedData,
            producedInfluences: InfluencesMap
    ) {
        var similarityRate = 0.0
        var castedPublicLocalState = publicLocalState as TurtlePLSInLogo
        var castedPerceivedData = perceivedData as TurtlePerceivedData
        for (perceivedTurtle in castedPerceivedData.getTurtles()) {
            var castedPerceivedTurtle = perceivedTurtle.getContent() as TurtlePLSInLogo
            if (castedPerceivedTurtle.getCategoryOfAgent().isA(castedPublicLocalState.getCategoryOfAgent())) {
                similarityRate++
            }
        }
        if (!castedPerceivedData.getTurtles().isEmpty()) {
            similarityRate /= castedPerceivedData.getTurtles().size
        }
        if (similarityRate &lt; this.parameters.similarityRate) {
            producedInfluences.add(Move(timeLowerBound, timeUpperBound, castedPublicLocalState))
        }
    }

}</code></pre>
<h4 id="reaction-model-3">Reaction model</h4>
<p>The reaction model handles the <code>Move</code> influences emitted by unhappy turtles. First, it identifies vacant places and moves the turtles that have emitted a <code>Move</code> influence. Note that if there is not enough vacant places, not all turtle wishes can be fulfilled.</p>
<pre><code>class SegregationReactionModel : LogoDefaultReactionModel() {

    override fun makeRegularReaction(
            transitoryTimeMin: SimulationTimeStamp,
            transitoryTimeMax: SimulationTimeStamp,
            consistentState: ConsistentPublicLocalDynamicState,
            regularInfluencesOftransitoryStateDynamics: Set&lt;IInfluence&gt;,
            remainingInfluences: InfluencesMap
    ) {
        //If there there is at least an agent that wants to move
        if (regularInfluencesOftransitoryStateDynamics.size &gt; 2) {
            var specificInfluences = ArrayList&lt;IInfluence&gt;()
            var vacantPlaces = ArrayList&lt;Point2D&gt;()
            specificInfluences.addAll(regularInfluencesOftransitoryStateDynamics)
            PRNG.shuffle(specificInfluences)
            //Identify vacant places
            var castedEnvState = consistentState.getPublicLocalStateOfEnvironment() as LogoEnvPLS
            for (x in 0..castedEnvState.getWidth()-1) {
                for (y in 0..castedEnvState.getHeight()-1) {
                    if (castedEnvState.getTurtlesAt(x, y).isEmpty()) {
                        vacantPlaces.add(
                                Point2D.Double(x.toDouble(), y.toDouble())
                        )
                    }
                }
            }
            PRNG.shuffle(vacantPlaces)
            //move agents
            var i = 0
            for (influence in specificInfluences) {
                if (influence.getCategory().equals(&quot;move&quot;)) {
                    var castedInfluence = influence as Move
                    castedEnvState.getTurtlesInPatches()[Math.floor(castedInfluence.target.getLocation().getX()).toInt()][Math.floor(castedInfluence.target.getLocation().getY()).toInt()].clear()
                    castedEnvState.getTurtlesInPatches()[Math.floor(vacantPlaces.get(i).getX()).toInt()][Math.floor(vacantPlaces.get(i).getY()).toInt()].add(castedInfluence.target)
                    castedInfluence.target.setLocation(vacantPlaces.get(i))
                    i++
                }
                if (i &gt;= vacantPlaces.size) {
                    break
                }
            }
        }
    }
}</code></pre>
<h4 id="simulation-model-5">Simulation model</h4>
<p>The simulation model generates the Logo level using the user-defined reaction model and a simple periodic time model. It also generates turtles of 2 different types (a and b) randomly in the grid with respect to the vacancy rate parameter.</p>
<pre><code>class SegregationSimulationModel(parameters: LogoSimulationParameters) : AbstractLogoSimulationModel(parameters) {


    override fun generateLevels(
            simulationParameters: ISimulationParameters
    ): List&lt;ILevel&gt; {
        var logo = ExtendedLevel(
                simulationParameters.getInitialTime(),
                LogoSimulationLevelList.LOGO,
                PeriodicTimeModel(
                        1,
                        0,
                        simulationParameters.getInitialTime()
                ),
                SegregationReactionModel()
        )
        var levelList = LinkedList&lt;ILevel&gt;()
        levelList.add(logo)
        return levelList
    }

    override fun generateAgents(
            parameters: ISimulationParameters,
            levels: Map&lt;LevelIdentifier, ILevel&gt;
    ): AgentInitializationData {
        var castedParameters = parameters as SegregationSimulationParameters
        var result = AgentInitializationData()
        var t: String
        for (x in 0..castedParameters.gridWidth-1) {
            for (y in 0..castedParameters.gridHeight-1) {
                if (PRNG.randomDouble() &gt;= castedParameters.vacancyRate) {
                    if (PRNG.randomBoolean()) {
                        t = &quot;a&quot;
                    } else {
                        t = &quot;b&quot;
                    }
                    var turtle = TurtleFactory.generate(
                            ConeBasedPerceptionModel(castedParameters.perceptionDistance, 2 * Math.PI, true, false, false),
                            SegregationAgentDecisionModel(castedParameters),
                            AgentCategory(t, TurtleAgentCategory.CATEGORY),
                            0.0,
                            0.0,
                            0.0,
                            x.toDouble(),
                            y.toDouble()
                    );
                    result.getAgents().add(turtle)
                }
            }
        }
        return result
    }

}</code></pre>
<h4 id="html-gui-3"><a name="segregationgui"></a> HTML GUI</h4>
<p>The HTML GUI specifies how turtles are displayed in the grid.Turtles of type a are colored in blue and turtles of type b are colored in red.</p>
<pre><code>&lt;canvas id=&#39;grid_canvas&#39; class=&#39;center-block&#39; width=&#39;400&#39; height=&#39;400&#39;&gt;&lt;/canvas&gt;
&lt;script type=&#39;text/javascript&#39;&gt;
    drawCanvas = function (data) {
        var json = JSON.parse(data),
            canvas = document.getElementById(&#39;grid_canvas&#39;),
            context = canvas.getContext(&#39;2d&#39;);
        context.clearRect(0, 0, canvas.width, canvas.height);
        for (var i = 0; i &lt; json.agents.length; i++) {
            var centerX = json.agents[i].x * canvas.width;
            var centerY = json.agents[i].y * canvas.height;
            var radius = 2;
            if (json.agents[i].t == &#39;a&#39;) {
                context.fillStyle = &#39;red&#39;;
            } else {
                context.fillStyle = &#39;blue&#39;;
            }
            context.beginPath();
            context.arc(centerX, centerY, radius, 0, 2 * Math.PI, false);
            context.fill();
        }
    }
&lt;/script&gt;</code></pre>
<h4 id="main-class-2">Main class</h4>
<p>The main function simply launches and configures the HTML runner with the above described GUI.</p>
<pre><code>fun main(args: Array&lt;String&gt;) {
    var runner = Similar2LogoWebRunner()
    runner.getConfig().setCustomHtmlBodyFromString(
            SegregationSimulationMain::class.java.getResource(&quot;segregationgui.html&quot;).readText()
    )
    // Configuration of the runner
    runner.getConfig().setExportAgents(true)
    // Creation of the model
    var model = SegregationSimulationModel(SegregationSimulationParameters())
    // Initialize the runner with the model
    runner.initializeRunner(model)
    // Add other probes to the engine
    // Open the GUI.
    runner.showView()
}</code></pre>
<h2 id="python-examples"><a name="pexamples"></a> Python Examples</h2>
<p>In the following we comment the examples written in Python distributed with Similar2Logo. Each example introduces a specific feature.</p>
<ul>
<li><p><a href="#ppassive">A first example with a passive turtle</a></p></li>
<li><p><a href="#pboids">Adding a user-defined decision model to the turtles: The boids model</a></p></li>
<li><p><a href="#pturmite">Dealing with marks: the turmite model</a></p></li>
<li><p><a href="#pmultiturmite">Adding an interaction and a user-defined reaction model: The multiturmite model</a></p></li>
</ul>
<h3 id="a-first-example-with-a-passive-turtle-4"><a name="ppassive"></a> A first example with a passive turtle</h3>
<p>First we consider a simple example with a single passive agent. The example source code is located in the package <code>fr.univ_artois.lgi2a.similar2logo.examples.passive</code>. It contains 1 python script.</p>
<p>Foremost, we define the parameters of the model by creating an object that inherits from <code>LogoSimulationParameters</code>, that contains the generic parameters of a Logo-like simulation (environment size, topology, etc.).</p>
<pre><code>class PassiveTurtleSimulationParameters(LogoSimulationParameters): 

    def __init__(self):
        self.initialX = 10.0
        self.initialY = 10.0
        self.initialSpeed = 0.1
        self.initialAcceleration = 0.0
        self.initialDirection = LogoEnvPLS.NORTH</code></pre>
<p>Then, we define the simulation model i.e, the initial state of the simulation from the <code>AbstractLogoSimulationModel</code> class. We must implement the <code>generateAgents</code> method to describe the initial state of our passive turtle.</p>
<pre><code>class PassiveTurtleSimulationModel(AbstractLogoSimulationModel):
    
    def __init__(self, parameters):
        super(PassiveTurtleSimulationModel, self).__init__(parameters)
    
    def generateAgents(self, parameters, levels):
        result = AgentInitializationData()
        turtle = TurtleFactory.generate(
            EmptyPerceptionModel(),
            PassiveTurtleDecisionModel(),
            AgentCategory(&#39;passive&#39;, [TurtleAgentCategory.CATEGORY]),
            parameters.initialDirection,
            parameters.initialSpeed,
            parameters.initialAcceleration,
            parameters.initialX,
            parameters.initialY
        )
        result.agents.add(turtle)
        return result</code></pre>
<p>Then we launch and configure the HTML runner. Here, only the turtles are displayed. Finally, the probe <code>RealTimeMatcherProbe</code> is added to the server to slow down the simulation so that its execution speed matches a specific factor of N steps per second.</p>
<pre><code>runner = Similar2LogoWebRunner()
runner.config.setExportAgents(True)
model = PassiveTurtleSimulationModel(PassiveTurtleSimulationParameters())
runner.initializeRunner(model)
runner.addProbe(&#39;Real time matcher&#39;, RealTimeMatcherProbe(20.0))
runner.showView()</code></pre>
<p><a name="pboids"></a> Adding a user-defined decision module to the turtles: The boids model</p>
<p>The <a href="https://en.wikipedia.org/wiki/Boids">boids</a> (bird-oid) model has been invented by <a href="https://en.wikipedia.org/wiki/Craig_Reynolds_(computer_graphics)">Craig Reynolds</a> in 1986 to simulate the flocking behavior of birds. It is based on 3 principles:</p>
<ul>
<li><p>separation: boids tend to avoid other boids that are too close,</p></li>
<li><p>alignment: boids tend to align their velocity to boids that are not too close and not too far away,</p></li>
<li><p>cohesion: bois tend to move towards boids that are too far away.</p></li>
</ul>
<p>While these rules are essentially heuristic, they can be implemented defining three areas (repulsion, orientation, attraction) for each principle.</p>
<ul>
<li><p>Boids change their orientation to get away from other boids in the repulsion area,</p></li>
<li><p>Boids change their orientation and speed to match those of other boids in the orientation area,</p></li>
<li><p>Boids change their orientation to get to other boids in the attraction area.</p></li>
</ul>
<p>An implementation of such model is located in the package <code>fr.univ_artois.lgi2a.similar2logo.examples.boids</code> which contains 1 python script called <code>BoidsSimulation.py</code>.</p>
<h4 id="model-parameters-14">Model parameters</h4>
<p>The model parameters and their default values are defined as in the previous example.</p>
<pre><code>class BoidsSimulationParameters(LogoSimulationParameters): 

    def __init__(self):
        self.repulsionDistance = 6.0
        self.orientationDistance = 10.0
        self.attractionDistance = 14.0
        self.repulsionWeight = 1.0
        self.orientationWeight = 1.0
        self.attractionWeight = 1.0
        self.maxInitialSpeed = 2.0
        self.minInitialSpeed = 1.0
        self.perceptionAngle = math.pi
        self.nbOfAgents = 200
        self.maxAngle = math.pi / 8</code></pre>
<h4 id="decision-model-8">Decision model</h4>
<p>The decision model consists in changing the direction and speed of the boids according to the previously described rules. To define a decision model, the modeler must define a class that extends <code>AbstractAgtDecisionModel</code> and implement the <code>decide</code> method.</p>
<pre><code>class BoidDecisionModel(AbstractAgtDecisionModel):
    
    def __init__(self, parameters):
        self.parameters = parameters
        super(BoidDecisionModel, self).__init__(LogoSimulationLevelList.LOGO)
    
    def decide(self, timeLowerBound, timeUpperBound, globalState, publicLocalState, privateLocalState, perceivedData, producedInfluences):
        if not perceivedData.turtles.isEmpty():
            orientationSpeed = 0.0
            nbOfTurtlesInOrientationArea = 0
            meanAngle = MeanAngle()
            for perceivedTurtle in perceivedData.turtles:
                if perceivedTurtle.distanceTo &lt;= self.parameters.repulsionDistance:
                    meanAngle.add(
                        publicLocalState.direction - perceivedTurtle.directionTo,
                        self.parameters.repulsionWeight
                    )
                elif perceivedTurtle.distanceTo &lt;= self.parameters.orientationDistance:
                    meanAngle.add(
                        perceivedTurtle.content.direction - publicLocalState.direction,
                        self.parameters.orientationWeight
                    )
                    orientationSpeed += perceivedTurtle.content.speed - publicLocalState.speed
                    nbOfTurtlesInOrientationArea+=1
                elif perceivedTurtle.distanceTo &lt;= self.parameters.attractionDistance:
                    meanAngle.add(
                        perceivedTurtle.directionTo - publicLocalState.direction,
                        self.parameters.attractionWeight
                    )
   
            dd = meanAngle.value()
            if not MathUtil.areEqual(dd, 0.0):
                if dd &gt; self.parameters.maxAngle:
                    dd = self.parameters.maxAngle
                elif dd &lt; -self.parameters.maxAngle:
                    dd = -self.parameters.maxAngle

                producedInfluences.add(
                    ChangeDirection(
                        timeLowerBound,
                        timeUpperBound,
                        dd,
                        publicLocalState
                    )
                )
                
            if  nbOfTurtlesInOrientationArea &gt; 0:
                orientationSpeed /= nbOfTurtlesInOrientationArea;
                producedInfluences.add(
                    ChangeSpeed(
                        timeLowerBound,
                        timeUpperBound,
                        orientationSpeed,
                        publicLocalState
                    )
                )</code></pre>
<h4 id="the-simulation-model-11">The simulation model</h4>
<p>In the simulation model defined in our example, boids are initially located at the center of the environment with a random orientation and speed.</p>
<pre><code>class BoidsSimulationModel(AbstractLogoSimulationModel):
    
    def __init__(self, parameters):
        super(BoidsSimulationModel, self).__init__(parameters)
    
    def generateBoid(self, p):
        return TurtleFactory.generate(
            ConeBasedPerceptionModel(
                p.attractionDistance, p.perceptionAngle, True, False, False
            ),
            BoidDecisionModel(p),
            AgentCategory(&quot;b&quot;, [TurtleAgentCategory.CATEGORY]),
            PRNG.randomAngle(),
            p.minInitialSpeed + PRNG.randomDouble() * (
                p.maxInitialSpeed - p.minInitialSpeed
            ),
            0.0,
            PRNG.randomDouble() * p.gridWidth,
            PRNG.randomDouble() * p.gridHeight
        )
        
    def generateAgents(self, parameters, levels):
        result = AgentInitializationData()
        for i in range(0, parameters.nbOfAgents):
            result.agents.add(self.generateBoid(parameters))
        return result</code></pre>
<h4 id="launch-the-html-runner-6">Launch the HTML runner</h4>
<p>Finally, we launch and configure the HTML runner as in the previous example.</p>
<pre><code>runner = Similar2LogoWebRunner()
runner.config.setExportAgents(True)
model = BoidsSimulationModel(BoidsSimulationParameters())
runner.initializeRunner(model)
runner.showView()</code></pre>
<h3 id="dealing-with-marks-the-turmite-model-4"><a name="pturmite"></a> Dealing with marks: the turmite model</h3>
<p>The <a href="https://en.wikipedia.org/wiki/Langton&#39;s_ant">turmite model</a>, developed by <a href="https://en.wikipedia.org/wiki/Christopher_Langton">Christopher Langton</a> in 1986, is a very simple mono-agent model that exhibits an emergent behavior. It is based on 2 rules:</p>
<ul>
<li><p>If the turmite is on a patch that does not contain a mark, it turns right, drops a mark, and moves forward,</p></li>
<li><p>If the turmite is on a patch that contains a mark, it turns left, removes the mark, and moves forward.</p></li>
</ul>
<p>The example source code is located in the package <code>fr.univ_artois.lgi2a.similar2logo.examples.turmite</code>. It contains 1 python script called <code>TurmiteSimulation.py</code>.</p>
<h4 id="model-parameters-15">Model parameters</h4>
<p>First we define the simulation parameters. Here we only need to specify the final step of the simulation:</p>
<pre><code>def parameters = new LogoSimulationParameters(                                              
    finalTime: new SimulationTimeStamp(100000)
)</code></pre>
<h4 id="the-decision-model-3">The decision model</h4>
<p>The decision model implements the above described rules :</p>
<pre><code>class TurmiteDecisionModel(AbstractAgtDecisionModel):
    
    def __init__(self):
        super(TurmiteDecisionModel, self).__init__(LogoSimulationLevelList.LOGO)
    
    def decide(self, timeLowerBound, timeUpperBound, globalState, publicLocalState, privateLocalState, perceivedData, producedInfluences):
        if perceivedData.marks.isEmpty():
            producedInfluences.add(
                ChangeDirection(
                    timeLowerBound,
                    timeUpperBound,
                    math.pi/2,
                    publicLocalState
                )
            )
            producedInfluences.add(
                DropMark(
                    timeLowerBound,
                    timeUpperBound,
                    Mark(
                        publicLocalState.location.clone(),
                        None
                    )
                )
            )
        else:
            producedInfluences.add(
                ChangeDirection(
                    timeLowerBound,
                    timeUpperBound,
                    -math.pi/2,
                    publicLocalState
                )
            )
            
            producedInfluences.add(
                RemoveMark(
                    timeLowerBound,
                    timeUpperBound,
                    perceivedData.marks.iterator().next().content
                )
            )</code></pre>
<h4 id="the-simulation-model-12">The simulation model</h4>
<p>The simulation model generates a turmite heading north at the location 10.5,10.5 with a speed of 1 and an acceleration of 0:</p>
<pre><code>class TurmiteSimulationModel(AbstractLogoSimulationModel):
    
    def __init__(self, parameters):
        super(TurmiteSimulationModel, self).__init__(parameters)
    
    def generateAgents(self, parameters, levels):
        result = AgentInitializationData()
        turtle = TurtleFactory.generate(
            ConeBasedPerceptionModel(0.0, 2 * math.pi, False, True, False),
            TurmiteDecisionModel(),
            AgentCategory(&#39;turmite&#39;, [TurtleAgentCategory.CATEGORY]),
            LogoEnvPLS.NORTH,
            1.0,
            0.0,
            10.5,
            10.5
        )
        result.agents.add(turtle)
        return result</code></pre>
<h4 id="launch-the-html-runner-7">Launch the HTML runner</h4>
<pre><code>runner = Similar2LogoWebRunner()
runner.config.setExportAgents(True)
runner.config.setExportMarks(True)
model = TurmiteSimulationModel(LogoSimulationParameters())
runner.initializeRunner(model)
runner.addProbe(&#39;Real time matcher&#39;, RealTimeMatcherProbe(20.0))
runner.showView()</code></pre>
<p>The main difference with the previous example is that in this case we want to observe turtles and marks.</p>
<h3 id="adding-an-interaction-and-a-user-defined-reaction-model-the-multiturmite-model-2"><a name="pmultiturmite"></a> Adding an interaction and a user-defined reaction model: The multiturmite model</h3>
<p>The goal of this example is to implement the multiturmite model proposed by <a href="http://www.loria.fr/~fates/">N. Fatès</a> and <a href="http://www.loria.fr/~chevrier/">V. Chevrier</a> in <a href="http://www.ifaamas.org/Proceedings/aamas2010/pdf/01%20Full%20Papers/11_04_FP_0210.pdf">this paper</a>. It extends the traditional <a href="http://en.wikipedia.org/wiki/Langton%27s_ant">Langton’s ant model</a> by specifying what happens when conflicting influences (removing or dropping a mark to the same location) are detected. The following policy is applied:</p>
<ul>
<li><p>if the parameter <code>dropMark</code> is <code>True</code>, the dropping influence takes precedent over the removing one and reciprocally.</p></li>
<li><p>if the parameter <code>removeDirectionChange</code> is <code>True</code>, direction changes are not taken into account.</p></li>
</ul>
<p>It allows to define 4 different reaction models according to these parameters.</p>
<p>The example source code is located in the package <code>fr.univ_artois.lgi2a.similar2logo.examples.multiturmite</code>. It contains 1 python script called <code>MultiTurmiteSimulation.py</code>.</p>
<h4 id="model-parameters-16">Model parameters</h4>
<p>The model parameters are defined in the class <code>MultiTurmiteSimulationParameters</code>. It defines how influences are handled according to the previously defined policy, the number of turmites and their initial locations and directions.</p>
<pre><code>class MultiTurmiteSimulationParameters(LogoSimulationParameters): 

    def __init__(self):
        self.removeDirectionChange = False
        self.inverseMarkUpdate = False
        self.nbOfTurmites = 4
        self.initialLocations = [
            Point2D.Double(
                math.floor(self.gridWidth / 2.0),
                math.floor(self.gridHeight / 2.0)
            ),
            Point2D.Double(
                math.floor(self.gridWidth / 2.0),
                math.floor(self.gridHeight / 2.0) + 1
            ),
            Point2D.Double(
                math.floor(self.gridWidth / 2.0) + 10,
                math.floor(self.gridHeight / 2.0)
            ),
            Point2D.Double(
                math.floor(self.gridWidth / 2.0) + 10,
                math.floor(self.gridHeight / 2.0) + 1
            )
        ]
        self.initialDirections = [
            LogoEnvPLS.NORTH,
            LogoEnvPLS.SOUTH,
            LogoEnvPLS.NORTH,
            LogoEnvPLS.SOUTH
        ]</code></pre>
<p>In this case, we create a specific instance of the multiturmite model with 4 turmites. This configuration described by <a href="http://www.loria.fr/~fates/">N. Fatès</a> and <a href="http://www.loria.fr/~chevrier/">V. Chevrier</a> in <a href="http://www.ifaamas.org/Proceedings/aamas2010/pdf/01%20Full%20Papers/11_04_FP_0210.pdf">their paper</a> produces interesting and distinctive emergent behaviors according to the values of <code>dropMark</code> and <code>removeDirectionChange</code> parameters.</p>
<h4 id="the-reaction-model-2">The reaction model</h4>
<p>In the previous example, the influence management relies on the default reaction model defined in the class <code>LogoDefaultReactionModel</code>. Now, we want to handle some influences manually. To do so, we have to define a class <code>MultiTurmiteReactionModel</code> that inherits from <code>LogoDefaultReactionModel</code>. This class has one attribute: the parameters of the simulation.</p>
<p>The idea is to identify the influences that do not trigger a generic reaction and manage them separately. Non specific influences are handled by the regular reaction.</p>
<p>In this case, specific influences represents collisions between turtle decisions. We define a class <code>TurmiteInteraction</code> that explicitly represent possible collisions for each location.</p>
<pre><code>class TurmiteInteraction:
    
    def __init__(self):
        self.dropMarks = LinkedHashSet()
        self.removeMarks = LinkedHashSet()
        self.changeDirections = LinkedHashSet()
    
    def isColliding(self):
        return self.removeMarks.size() &gt; 1 or self.dropMarks.size() &gt; 1</code></pre>
<p>Then, it is easy to implement the reaction model whether the influences are colliding or not. To do so we redefine the <code>makeRegularReaction</code> method.</p>
<pre><code>class MultiTurmiteReactionModel(LogoDefaultReactionModel):
        
        def __init__(self,parameters):
            self.parameters = parameters

        def makeRegularReaction(
            self,
            transitoryTimeMin,
            transitoryTimeMax,
            consistentState,
            regularInfluencesOftransitoryStateDynamics,
            remainingInfluences
        ):
            nonSpecificInfluences = LinkedHashSet()
            collisions = {}
            
            for influence in regularInfluencesOftransitoryStateDynamics:
                if influence.category == DropMark.CATEGORY:
                    if not influence.mark.location in collisions:
                        collisions[influence.mark.location] = TurmiteInteraction()
                    collisions[influence.mark.location].dropMarks.add(influence)
                elif influence.category == RemoveMark.CATEGORY:
                    if not influence.mark.location in collisions:
                        collisions[influence.mark.location] = TurmiteInteraction()
                    collisions[influence.mark.location].removeMarks.add(influence)
                elif influence.category == ChangeDirection.CATEGORY:
                    if not influence.target.location in collisions:
                        collisions[influence.target.location] = TurmiteInteraction()
                    collisions[influence.target.location].changeDirections.add(influence)
                else:
                    nonSpecificInfluences.add(influence)

            for collision in collisions.values():
                if collision.isColliding():
                    if not collision.dropMarks.isEmpty() and not self.parameters.inverseMarkUpdate:
                        nonSpecificInfluences.add(
                            collision.dropMarks.iterator().next()
                        )
                    if not collision.removeMarks.isEmpty() and not self.parameters.inverseMarkUpdate:
                        nonSpecificInfluences.add(
                            collision.removeMarks.iterator().next()
                        )        
                    if not self.parameters.removeDirectionChange:
                        nonSpecificInfluences.addAll(collision.changeDirections)
                else:
                    nonSpecificInfluences.addAll(collision.changeDirections)
                    if not collision.dropMarks.isEmpty():
                        nonSpecificInfluences.add(
                            collision.dropMarks.iterator().next()
                        )
                    if not collision.removeMarks.isEmpty():
                        nonSpecificInfluences.add(
                            collision.removeMarks.iterator().next()
                        )
            super(MultiTurmiteReactionModel, self).makeRegularReaction(
                transitoryTimeMin,
                transitoryTimeMax,
                consistentState,
                nonSpecificInfluences,
                remainingInfluences
            )</code></pre>
<h4 id="the-simulation-model-13">The simulation model</h4>
<p>The simulation model of this example is located in the class <code>MultiTurmiteSimulationModel</code>.</p>
<p>Such as in the previous example, we have to redefine the function <code>generateAgents</code> to specify the initial population of agents of the simulation. However, contrary to the previous examples, we have to redefine the function <code>generateLevels</code> to specify the reaction model we use:</p>
<pre><code>class MultiTurmiteSimulationModel(AbstractLogoSimulationModel):
    
    def __init__(self, parameters):
        super(MultiTurmiteSimulationModel, self).__init__(parameters)
    
    def randomDirection(self):
        rand = PRNG.randomDouble()
        if rand &lt; 0.25:
            return LogoEnvPLS.NORTH
        elif rand &lt; 0.5:
            return LogoEnvPLS.WEST
        elif  rand &lt; 0.75:
            return LogoEnvPLS.SOUTH
        return LogoEnvPLS.EAST
    
    
    def generateLevels(self, simulationParameters):
        logo = ExtendedLevel(
            simulationParameters.initialTime,
            LogoSimulationLevelList.LOGO,
            PeriodicTimeModel(
                1,
                0,
                simulationParameters.initialTime
            ),
            MultiTurmiteReactionModel(simulationParameters)
        )
        levelList = []
        levelList.append(logo)
        return levelList</code></pre>
<h4 id="launch-the-html-runner-8">Launch the HTML runner</h4>
<pre><code>runner = Similar2LogoWebRunner()
runner.config.setExportAgents(True)
runner.config.setExportMarks(True)
model = MultiTurmiteSimulationModel(MultiTurmiteSimulationParameters())
runner.initializeRunner(model)
runner.addProbe(&#39;Real time matcher&#39;, RealTimeMatcherProbe(20.0))
runner.showView()    </code></pre>
<p>Such as in the previous example, we want to observe the turtles and the marks.</p>
            </div>
    </div>
  </div>
</body>
</html>
